---
title: "ODE_supp_figs"
author: "Raine Detmer"
date: "4/6/2023"
output: html_document
---

README: code for making all supplemental figures for the theoretical ODE model analyses (section 2 of the supplement, figures S1-S6)

# packages

```{r}
library(deSolve)

library(tictoc) # for timing simulations

library(tidyverse)

```

# default pars

```{r}
# local parameters
rho = 10 #kelp reproduction rate (spores/kg adults/d)
rG = 0.05 #gametophyte maturation rate
muG = 0.6 # gametophyte mortality rate
rJ = 0.004 #juvenile sporophyte growth rate
muJ = 0.01 #juvenile sporophyte mortality rate
K = 1 # adult carrying capacity (1 patch model)
K1 = 1 #adult carrying capacity in patch 1 (2 patch model)
K2 = 1 #adult carrying capacity in patch 2 (2 patch model)
muA = 0.002 #adult mortality rate 
qG = 1.2 # G's vulnerability to grazing relative to adults
qJ = 1.2 # J's vulnerability to grazing relative to adults
g = 0.025 #max urchin grazing rate on adults
p = 0.1 #proportional reduction in active grazing when production = consumption
d = 0.024 #fraction of biomass that becomes detritus
gd = 0.0011 #rate of urchin grazing on detritus
b = 7 #mean biomass per adult kelp plant 
u = 0 #urchin density (1 patch model)
u1 = 0 #urchin density in patch 1 (2 patch model)
u2 = 0 #urchin density in patch 2 (2 patch model)


#patch connectivities
cs1 = 0# fraction of spores leaving patch 1 that go to patch 2 (2 patch model)
cs2 = 0# fraction of spores leaving patch 2 that go to patch 1 (2 patch model)
cd1 = 0# fraction of drift kelp leaving patch 1 that go to patch 2 (2 patch model)
cd2 = 0 # fraction of drift kelp leaving patch 2 that go to patch 1 (2 patch model)
exts = 0 # external spore input (1 patch model)
exts1 = 0 #external spore input in patch 1 (2 patch model)
exts2 = 0 #external spore input in patch 2 (2 patch model) 
extd = 0 # external drift input (1 patch model)
extd1 = 0 #external drift input in patch 1 (2 patch model)
extd2 = 0 #external drift input in patch 2 (2 patch model)
ls = 0.5 #fraction of spores that leave patch (1 patch model)
ls1 = 0.5 #fraction of spores that leave patch 1 (2 patch model)
ls2 = 0.5 #fraction of spores that leave patch 2 (2 patch model)
ld = 0.5  #fraction of detritus that leaves patch (1 patch model)
ld1 = 0.5 #fraction of detritus that leaves patch 1 (2 patch model)
ld2 = 0.5 #fraction of detritus that leaves patch 2 (2 patch model)

```

# model function

2 patch 

```{r}
mod.fun2 <- function (t, state2, params2) {
  with(as.list(c(state2, params2)), {
    
     #grazing in patch 1 
    if(u1 == 0){
    graze1 <- 0
  } else{
    graze1 <- 1/(1+(1-p)/p*((extd1 + (1-ld1)*A1*b*d + ld2*cd2*b*d*A2)/(gd*u1))^2)
  }
     
     #grazing in patch 2 (focal patch)
     if(u2 == 0){
    graze2 <- 0
  } else{
    graze2 <- 1/(1+(1-p)/p*((extd2 + (1-ld2)*A2*b*d + ld1*cd1*b*d*A1)/(gd*u2))^2)
  }
    
    # ODE equations
  dG1dt <-  exts1 + (1-ls1)*b*rho*A1 + ls2*cs2*rho*b*A2 - rG*G1 - qG*g*u1*graze1*G1 - muG*G1*G1 #gametophytes
  dJ1dt <-  0.5*rG*G1- rJ*J1 - qJ*g*u1*graze1*J1 - muJ*J1*J1#juveniles
  dA1dt <-  rJ*J1*(1-A1/K1) - g*u1*graze1*A1 - muA*A1#adults
  
  dG2dt <-  exts2 + (1-ls2)*b*rho*A2 + ls1*cs1*rho*b*A1 - rG*G2 - qG*g*u2*graze2*G2 - muG*G2*G2 #gametophytes
  dJ2dt <-  0.5*rG*G2- rJ*J2 - qJ*g*u2*graze2*J2 - muJ*J2*J2#juveniles
  dA2dt <-  rJ*J2*(1-A2/K2) - g*u2*graze2*A2 - muA*A2#adults
  
  
  return(list(c(dG1dt, dJ1dt, dA1dt, dG2dt, dJ2dt, dA2dt)))
  })
    
}


```


# Fig S1

Type 4 functional response

```{r}
# urchin behavior function (function of the "steepness" p and the ratio of of drift production to consumption)
B.fun <- function(p.f, ratio.f){
  
  grazing <- 1/(1+(1-p.f)/p.f*(ratio.f)^2)
  
  return(grazing)
  
}

# vectorize the function to be able to input a vector of ratio values
B.funv <- Vectorize(B.fun, c("ratio.f"))

# plot Fig. S1
pdf("Bfun.pdf", width = 5, height = 4)
plot(x = seq(from = 0.0001, to = 2, length.out = 200), y = B.funv(p, seq(from = 0.0001, to = 2, length.out = 200)), type = "l", xlim = c(0,2), ylim = c(0, 1), xlab = NA, ylab = NA, las = 1)
mtext(side = 1, "Ratio of drift production to consumption rate", line = 2.5)
mtext(side = 2, "B(A, u)", line = 2.5)
mtext(side = 3, expression("Urchin feeding behavior function"~italic("B(A, u)")))
text(x = -0.02, y = 0.14, "p", cex = 1.1)
abline(h = p, lty = 2)
abline(v = 1, lty = 2)
dev.off()


```

# Fig S2

supplemental bifurcation diagrams (analyses were performed in Mathematica; see "ODE_bifurcation_analyses.nb")


```{r}
# import results from Mathematica

# biomass per plant (b)
# stable eq
b5Stab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/b5Stab.csv", header = FALSE)
colnames(b5Stab) <- c("urchins", "Astar")
b15Stab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/b15Stab.csv", header = FALSE)
colnames(b15Stab) <- c("urchins", "Astar")
b25Stab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/b25Stab.csv", header = FALSE)
colnames(b25Stab) <- c("urchins", "Astar")

# unstable eq
b5Unstab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/b5Unstab.csv", header = FALSE)
colnames(b5Unstab) <- c("urchins", "Astar")
b15Unstab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/b15Unstab.csv", header = FALSE)
colnames(b15Unstab) <- c("urchins", "Astar")
b25Unstab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/b25Unstab.csv", header = FALSE)
colnames(b25Unstab) <- c("urchins", "Astar")

# spore export rate (ls)
# stable eq
ls25Stab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ls25Stab.csv", header = FALSE)
colnames(ls25Stab) <- c("urchins", "Astar")
ls50Stab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ls50Stab.csv", header = FALSE)
colnames(ls50Stab) <- c("urchins", "Astar")
ls75Stab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ls75Stab.csv", header = FALSE)
colnames(ls75Stab) <- c("urchins", "Astar")

# unstable eq
ls25Unstab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ls25Unstab.csv", header = FALSE)
colnames(ls25Unstab) <- c("urchins", "Astar")
ls50Unstab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ls50Unstab.csv", header = FALSE)
colnames(ls50Unstab) <- c("urchins", "Astar")
ls75Unstab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ls75Unstab.csv", header = FALSE)
colnames(ls75Unstab) <- c("urchins", "Astar")

# drift export rate (ld)
# stable eq
ld25Stab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ld25Stab.csv", header = FALSE)
colnames(ld25Stab) <- c("urchins", "Astar")
ld50Stab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ld50Stab.csv", header = FALSE)
colnames(ld50Stab) <- c("urchins", "Astar")
ld75Stab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ld75Stab.csv", header = FALSE)
colnames(ld75Stab) <- c("urchins", "Astar")

# unstable eq
ld25Unstab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ld25Unstab.csv", header = FALSE)
colnames(ld25Unstab) <- c("urchins", "Astar")
ld50Unstab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ld50Unstab.csv", header = FALSE)
colnames(ld50Unstab) <- c("urchins", "Astar")
ld75Unstab <- read.csv("../../../intermediate_data_output/mathematica_output/bifur_supp/ld75Unstab.csv", header = FALSE)
colnames(ld75Unstab) <- c("urchins", "Astar")


```


format the data frames for plotting

```{r}

# function: for a given connectivity scenario, put in the data frame with the stable eq and the data frame with the unstable eq, return a list where the first element is the dataframe with all the non-zero equilibria with their stability labeled and the second element is the dataframe with all the zero equilibria with stability labeled
bifurplotdt.fun <- function(stabdt, unstabdt){
  stabdt.1 <- stabdt %>% mutate(stability = "stable") %>% filter(Astar !=0)
  stabdt.0 <- stabdt %>% mutate(stability = "stable") %>% filter(Astar ==0)
  unstabdt.1 <- unstabdt %>% mutate(stability = "unstable") %>% filter(Astar!=0)
  unstabdt.0 <- unstabdt %>% mutate(stability = "unstable") %>% filter(Astar==0)
  nonzerodt <- rbind(stabdt.1, unstabdt.1) %>% arrange(Astar)
  zerodt <- rbind(stabdt.0, unstabdt.0) %>% arrange(Astar)

return(list(nonzerodt, zerodt))
  
}

# biomass per plant
b5 <- bifurplotdt.fun(b5Stab,b5Unstab)
b15 <- bifurplotdt.fun(b15Stab,b15Unstab)
b25 <- bifurplotdt.fun(b25Stab,b25Unstab)

# spore export rate
ls25 <- bifurplotdt.fun(ls25Stab,ls25Unstab)
ls50 <- bifurplotdt.fun(ls50Stab,ls50Unstab)
ls75 <- bifurplotdt.fun(ls75Stab,ls75Unstab)

# drift export rate
ld25 <- bifurplotdt.fun(ld25Stab,ld25Unstab)
ld50 <- bifurplotdt.fun(ld50Stab,ld50Unstab)
ld75 <- bifurplotdt.fun(ld75Stab,ld75Unstab)


```

plot

```{r}
# colors
high.col <- "red"
low.col <- "blue"
mid.col <- "#33BEFF"

```

```{r}
pdf("Suppbifur.pdf", height = 7/2.5)# default height and width are both 7
par(mfrow = c(1, 3), oma = c(3.5, 4, 2, 1))
layout(matrix(c(1, 2, 3), nrow = 1, ncol = 3), widths = rep.int(1, 3), heights = rep.int(1, 1))
par(mar=c(0, 0, 0, 0.5))
# ls
plot(x =ls25[[1]]$urchins, y = ls25[[1]]$Astar, type = "l", xlim = c(0,100),ylim = c(0,0.9), lty = 2, xlab = NA, ylab = NA, las = 1, col = high.col)# plot everything with lty = 2
#mtext("Equilibrium kelp density", side=2, cex=1, line = 2.5)
mtext(expression("Equilibrium kelp density (ind./m"^2*")"), side=2, cex=0.95, line = 2.4)
mtext("a) Spore retention", side = 3, cex = 1, adj=0)
# add the upper stable section
lines(x =ls25[[1]]$urchins[which(ls25[[1]]$Astar>max(ls25[[1]]$Astar[which(ls25[[1]]$stability=="unstable")]))], y = ls25[[1]]$Astar[which(ls25[[1]]$Astar>max(ls25[[1]]$Astar[which(ls25[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = high.col)
# add the lower stable section
lines(x =ls25[[1]]$urchins[which(ls25[[1]]$Astar<min(ls25[[1]]$Astar[which(ls25[[1]]$stability=="unstable")]))], y = ls25[[1]]$Astar[which(ls25[[1]]$Astar<min(ls25[[1]]$Astar[which(ls25[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = high.col)
# add the unstable 0 eq (moved this at end of plot so the red line would be on top)
# add the stable 0 eq (moved this at end of plot so the red line would be on top)
# NEXT b VALUE b = 15 
lines(x =ls50[[1]]$urchins, y = ls50[[1]]$Astar, type = "l", lty = 2, col = mid.col)
# add the upper stable section
lines(x =ls50[[1]]$urchins[which(ls50[[1]]$Astar>max(ls50[[1]]$Astar[which(ls50[[1]]$stability=="unstable")]))], y = ls50[[1]]$Astar[which(ls50[[1]]$Astar>max(ls50[[1]]$Astar[which(ls50[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = mid.col)
# add the lower stable section
lines(x =ls50[[1]]$urchins[which(ls50[[1]]$Astar<min(ls50[[1]]$Astar[which(ls50[[1]]$stability=="unstable")]))], y = ls50[[1]]$Astar[which(ls50[[1]]$Astar<min(ls50[[1]]$Astar[which(ls50[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = mid.col)
# add the unstable 0 eq
lines(ls50[[2]]$urchins[which(ls50[[2]]$stability=="stable")], y = ls50[[2]]$Astar[which(ls50[[2]]$stability=="stable")], type = "l", lty = 1, col = mid.col)
# add the stable 0 eq
lines(ls50[[2]]$urchins[which(ls50[[2]]$stability=="unstable")], y = ls50[[2]]$Astar[which(ls50[[2]]$stability=="unstable")], type = "l", lty = 2, col = mid.col)
# NEXT b VALUE: b= 25
lines(x =ls75[[1]]$urchins, y = ls75[[1]]$Astar, type = "l", lty = 2, col = low.col)
# add the upper stable section
lines(x =ls75[[1]]$urchins[which(ls75[[1]]$Astar>max(ls75[[1]]$Astar[which(ls75[[1]]$stability=="unstable")]))], y = ls75[[1]]$Astar[which(ls75[[1]]$Astar>max(ls75[[1]]$Astar[which(ls75[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = low.col)
# add the lower stable section
lines(x =ls75[[1]]$urchins[which(ls75[[1]]$Astar<min(ls75[[1]]$Astar[which(ls75[[1]]$stability=="unstable")]))], y = ls75[[1]]$Astar[which(ls75[[1]]$Astar<min(ls75[[1]]$Astar[which(ls75[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = low.col)
# add the unstable 0 eq
lines(ls75[[2]]$urchins[which(ls75[[2]]$stability=="stable")], y = ls75[[2]]$Astar[which(ls75[[2]]$stability=="stable")], type = "l", lty = 1, col = low.col)
# add the stable 0 eq
lines(ls75[[2]]$urchins[which(ls75[[2]]$stability=="unstable")], y = ls75[[2]]$Astar[which(ls75[[2]]$stability=="unstable")], type = "l", lty = 2, col = low.col)
# add the stable 0 eq for the high retention case
lines(ls25[[2]]$urchins[which(ls25[[2]]$stability=="stable")], y = ls25[[2]]$Astar[which(ls25[[2]]$stability=="stable")], type = "l", lty = 1, col = high.col)
# add the unstable 0 eq for the high retention case
lines(ls25[[2]]$urchins[which(ls25[[2]]$stability=="unstable")], y = ls25[[2]]$Astar[which(ls25[[2]]$stability=="unstable")], type = "l", lty = 2, col = high.col)
# add connectivity level
legend(x = "topright", legend = c("0.25", "0.5", "0.75"), col = c(low.col, mid.col, high.col), lwd = 1, title = "Fraction retained", bty= "n", cex = 1.1)
legend(x = "right", legend = c("stable", "unstable"), lty = c(1, 2), col = c("black", "black"), lwd = 1, title = "Stability", bty= "n", cex = 1.1)

# ld
plot(x =ld25[[1]]$urchins, y = ld25[[1]]$Astar, type = "l", xlim = c(0,100),ylim = c(0,0.9), lty = 2, xlab = NA, ylab = NA, las = 1, col = high.col, yaxt = "n")# plot everything with lty = 2
#mtext("Equilibrium kelp density", side=2, cex=1, line = 2.5)
axis(2, at = c(0, 0.2, 0.4, 0.6, 0.8), labels = NA)# to show tick marks but not tick labels, need to make yaxt = "n" then add axis() with labels = NA
mtext("b) Drift retention", side = 3, cex = 1, adj=0)
#mtext("Urchin density", side=1, cex=1, line = 2.5, outer=TRUE)#outer=TRUE, adj=0.5,
mtext(expression("Urchin density (ind./m"^2*")"), side=1, cex=0.95, line = 2.5, outer=TRUE)
# add the upper stable section
lines(x =ld25[[1]]$urchins[which(ld25[[1]]$Astar>max(ld25[[1]]$Astar[which(ld25[[1]]$stability=="unstable")]))], y = ld25[[1]]$Astar[which(ld25[[1]]$Astar>max(ld25[[1]]$Astar[which(ld25[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = high.col)
# add the lower stable section
lines(x =ld25[[1]]$urchins[which(ld25[[1]]$Astar<min(ld25[[1]]$Astar[which(ld25[[1]]$stability=="unstable")]))], y = ld25[[1]]$Astar[which(ld25[[1]]$Astar<min(ld25[[1]]$Astar[which(ld25[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = high.col)
# add the unstable 0 eq (moved this at end of plot so the red line would be on top)
# add the stable 0 eq (moved this at end of plot so the red line would be on top)
# NEXT b VALUE b = 15 
lines(x =ld50[[1]]$urchins, y = ld50[[1]]$Astar, type = "l", lty = 2, col = mid.col)
# add the upper stable section
lines(x =ld50[[1]]$urchins[which(ld50[[1]]$Astar>max(ld50[[1]]$Astar[which(ld50[[1]]$stability=="unstable")]))], y = ld50[[1]]$Astar[which(ld50[[1]]$Astar>max(ld50[[1]]$Astar[which(ld50[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = mid.col)
# add the lower stable section
lines(x =ld50[[1]]$urchins[which(ld50[[1]]$Astar<min(ld50[[1]]$Astar[which(ld50[[1]]$stability=="unstable")]))], y = ld50[[1]]$Astar[which(ld50[[1]]$Astar<min(ld50[[1]]$Astar[which(ld50[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = mid.col)
# add the unstable 0 eq
lines(ld50[[2]]$urchins[which(ld50[[2]]$stability=="stable")], y = ld50[[2]]$Astar[which(ld50[[2]]$stability=="stable")], type = "l", lty = 1, col = mid.col)
# add the stable 0 eq
lines(ld50[[2]]$urchins[which(ld50[[2]]$stability=="unstable")], y = ld50[[2]]$Astar[which(ld50[[2]]$stability=="unstable")], type = "l", lty = 2, col = mid.col)
# NEXT b VALUE: b= 25
lines(x =ld75[[1]]$urchins, y = ld75[[1]]$Astar, type = "l", lty = 2, col = low.col)
# add the upper stable section
lines(x =ld75[[1]]$urchins[which(ld75[[1]]$Astar>max(ld75[[1]]$Astar[which(ld75[[1]]$stability=="unstable")]))], y = ld75[[1]]$Astar[which(ld75[[1]]$Astar>max(ld75[[1]]$Astar[which(ld75[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = low.col)
# add the lower stable section
lines(x =ld75[[1]]$urchins[which(ld75[[1]]$Astar<min(ld75[[1]]$Astar[which(ld75[[1]]$stability=="unstable")]))], y = ld75[[1]]$Astar[which(ld75[[1]]$Astar<min(ld75[[1]]$Astar[which(ld75[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = low.col)
# add the unstable 0 eq
lines(ld75[[2]]$urchins[which(ld75[[2]]$stability=="stable")], y = ld75[[2]]$Astar[which(ld75[[2]]$stability=="stable")], type = "l", lty = 1, col = low.col)
# add the stable 0 eq
lines(ld75[[2]]$urchins[which(ld75[[2]]$stability=="unstable")], y = ld75[[2]]$Astar[which(ld75[[2]]$stability=="unstable")], type = "l", lty = 2, col = low.col)
# add the stable 0 eq for the high retention case
lines(ld25[[2]]$urchins[which(ld25[[2]]$stability=="stable")], y = ld25[[2]]$Astar[which(ld25[[2]]$stability=="stable")], type = "l", lty = 1, col = high.col)
# add the unstable 0 eq for the high retention case
lines(ld25[[2]]$urchins[which(ld25[[2]]$stability=="unstable")], y = ld25[[2]]$Astar[which(ld25[[2]]$stability=="unstable")], type = "l", lty = 2, col = high.col)
# add connectivity level
legend(x = "topright", legend = c("0.25", "0.5", "0.75"), col = c(low.col, mid.col, high.col), lwd = 1, title = "Fraction retained", bty= "n", cex = 1.1)
#legend(x = "right", legend = c("stable", "unstable"), lty = c(1, 2), col = c("black", "black"), lwd = 1, title = "Stability", bty= "n", cex = 1.1)

plot(x =b5[[1]]$urchins, y = b5[[1]]$Astar, type = "l", xlim = c(0,100),ylim = c(0,0.9), lty = 2, xlab = NA, ylab = NA, las = 1, col = low.col, yaxt = "n")# plot everything with lty = 2
#mtext("Equilibrium kelp density", side=2, cex=1, line = 2.5)
mtext("a) Kelp biomass", side = 3, cex = 1, adj=0)
axis(2, at = c(0, 0.2, 0.4, 0.6, 0.8), labels = NA)# to show tick marks but not tick labels, need to make yaxt = "n" then add axis() with labels = NA
# add the upper stable section
lines(x =b5[[1]]$urchins[which(b5[[1]]$Astar>max(b5[[1]]$Astar[which(b5[[1]]$stability=="unstable")]))], y = b5[[1]]$Astar[which(b5[[1]]$Astar>max(b5[[1]]$Astar[which(b5[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = low.col)
# add the lower stable section
lines(x =b5[[1]]$urchins[which(b5[[1]]$Astar<min(b5[[1]]$Astar[which(b5[[1]]$stability=="unstable")]))], y = b5[[1]]$Astar[which(b5[[1]]$Astar<min(b5[[1]]$Astar[which(b5[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = low.col)
# add the unstable 0 eq
lines(b5[[2]]$urchins[which(b5[[2]]$stability=="stable")], y = b5[[2]]$Astar[which(b5[[2]]$stability=="stable")], type = "l", lty = 1, col = low.col)
# add the stable 0 eq
lines(b5[[2]]$urchins[which(b5[[2]]$stability=="unstable")], y = b5[[2]]$Astar[which(b5[[2]]$stability=="unstable")], type = "l", lty = 2, col = low.col)
# NEXT b VALUE b = 15 
lines(x =b15[[1]]$urchins, y = b15[[1]]$Astar, type = "l", lty = 2, col = mid.col)
# add the upper stable section
lines(x =b15[[1]]$urchins[which(b15[[1]]$Astar>max(b15[[1]]$Astar[which(b15[[1]]$stability=="unstable")]))], y = b15[[1]]$Astar[which(b15[[1]]$Astar>max(b15[[1]]$Astar[which(b15[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = mid.col)
# add the lower stable section
lines(x =b15[[1]]$urchins[which(b15[[1]]$Astar<min(b15[[1]]$Astar[which(b15[[1]]$stability=="unstable")]))], y = b15[[1]]$Astar[which(b15[[1]]$Astar<min(b15[[1]]$Astar[which(b15[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = mid.col)
# add the unstable 0 eq
lines(b15[[2]]$urchins[which(b15[[2]]$stability=="stable")], y = b15[[2]]$Astar[which(b15[[2]]$stability=="stable")], type = "l", lty = 1, col = mid.col)
# add the stable 0 eq
lines(b15[[2]]$urchins[which(b15[[2]]$stability=="unstable")], y = b15[[2]]$Astar[which(b15[[2]]$stability=="unstable")], type = "l", lty = 2, col = mid.col)
# NEXT b VALUE: b= 25
lines(x =b25[[1]]$urchins, y = b25[[1]]$Astar, type = "l", lty = 2, col = high.col)
# add the upper stable section
lines(x =b25[[1]]$urchins[which(b25[[1]]$Astar>max(b25[[1]]$Astar[which(b25[[1]]$stability=="unstable")]))], y = b25[[1]]$Astar[which(b25[[1]]$Astar>max(b25[[1]]$Astar[which(b25[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = high.col)
# add the lower stable section
lines(x =b25[[1]]$urchins[which(b25[[1]]$Astar<min(b25[[1]]$Astar[which(b25[[1]]$stability=="unstable")]))], y = b25[[1]]$Astar[which(b25[[1]]$Astar<min(b25[[1]]$Astar[which(b25[[1]]$stability=="unstable")]))], type = "l", lwd = 1.1, col = high.col)
# add the unstable 0 eq
lines(b25[[2]]$urchins[which(b25[[2]]$stability=="stable")], y = b25[[2]]$Astar[which(b25[[2]]$stability=="stable")], type = "l", lty = 1, col = high.col)
# add the stable 0 eq
lines(b25[[2]]$urchins[which(b25[[2]]$stability=="unstable")], y = b25[[2]]$Astar[which(b25[[2]]$stability=="unstable")], type = "l", lty = 2, col = high.col)
# add connectivity level
legend(x = "topright", legend = c("5", "15", "25"), col = c(low.col, mid.col, high.col), lwd = 1, title = "Biomass/individual", bty= "n", cex = 1.1)
#legend(x = "right", legend = c("stable", "unstable"), lty = c(1, 2), col = c("black", "black"), lwd = 1, title = "Stability", bty= "n", cex = 1.1)
dev.off()

```


# Fig S3

Sensitivity of the region of bistability to model parameters

## high and low initial conditions

First get the upper and lowermost sets of initial conditions to test

```{r}
#parameters
params.02 = c(cs1 = 1, cs2 = 1, cd1 = 1, cd2 = 1, exts1, exts2, extd1, extd2, ls1, ls2, ld1, ld2, rho, rG, muG, rJ, muJ, K1, K2, muA, qG, qJ, g, p, d, gd, b, u1 = 0, u2=0)

# initial conditions
xic.02 <- c(G1 = 5, J1= 5, A1= 1, G2 = 5, J2= 5, A2= 1)

#time
times.02 = seq(from = 0, to = 3000, length.out = 3000)

#run the model
results.02 <- ode(xic.02, times.02, mod.fun2, params.02, method = "lsodes")#switched to lsodes from lsoda because the system was stiff (for high urchins, the end of the simulation was NA)
colnames(results.02) = c("time", "G1", "J1", "A1", "G2", "J2", "A2")


# check the system equilibrates
#plot(x = results.02[ ,"time"], y = results.02[ ,"A1"], type = 'l', las = 1, lwd = 2, xlab = 'Time', ylab = 'adults/m2', ylim = c(0, 1))
#plot(x = results.02[ ,"time"], y = results.02[ ,"A2"], type = 'l', las = 1, lwd = 2, xlab = 'Time', ylab = 'adults/m2', ylim = c(0, 1))

# store the equilibrium values
Aheq <- unname(results.02[length(times.02) ,"A1"])# unname this because otherwise it is names "A" which causes issues when assigning it as an initial condition - end up with an A.A
Jheq <- unname(results.02[length(times.02) ,"J1"])
Gheq <- unname(results.02[length(times.02) ,"G1"])

# high and low initial conditions
# high values: equilibrium values of fully connected patches with no urchins (highest possible)
G0.h <- Gheq
J0.h <- Jheq
A0.h <- Aheq

# low values: no juvenile or adult sporophytes, negligible amount of gametophytes
G0.l <- 0.0001
J0.l <- 0
A0.l <- 0

```


## function

Make a function that takes in the vector of values of a parameter of interest and returns the upper and lower threshold urchin densities within the region of bistability

Note this is using the two patch model so that the local conditions in the source patch change with the changing parameter values (similar to running the model to equilibrium and using the resulting equilibrium production rates to get the external input values). Patch 2 is the focal patch. Source patch (patch 1) has no urchins, starts high, and doesn't get anything from patch 2 (no feedback; just a "mainland" source of spores and/or drift depending on the connectivity scenario)

```{r}

# define parameters outside of the function 
parsbase <-  c(cs1=0, cs2=0, cd1=0, cd2=0, exts1=0, exts2=0, extd1=0, extd2=0, ls1=0.5, ls2=0.5, ld1=0.5, ld2=0.5, rho=10, rG=0.05, muG=0.6, rJ=0.004, muJ=0.01, K1=1, K2=1, muA=0.002, qG=1.2, qJ=1.2, g=0.025, p=0.1, d=0.024, gd=0.0011, b=7, u1 = 0, u2=0) # note everything needs to be named with the same name as in the ode function in order to change parameter values

# define the function
thresh.fun <- function(par.vec, par.index, cs.f, cd.f){ # par.vec = vector of different values of the parameter of interest to test, par.index = the index of the vector of parameters corresponding to the parameter of interest, cs.f = value of spore connectivity, cd.f = value of drift connectivity
  
  # get the lower urchin threshold for each value of par.vec
  
  #holding vector for the critical urchin densities for each value of the parameter
lowerthresh <- NaN*par.vec

for(j in 1:length(par.vec)){
  
  # get the parameter set (without urchin densities)
  parset.f1 <- parsbase[1:27]
  
  # important: the default values in the ode simulations won't change unless the values are named in the parameter vector, so need to keep the name of the parameter when changing its value (e.g., need to change b=7 to b=10 rather than changing b=7 to 10)

parset.f1[names(parset.f1[par.index])] <- par.vec[j] # change the element of parset.f that corresponds to the parameter of interest to the jth element of par.vec

  parset.f1[names(parset.f1[1])] <- cs.f # set the values of spore connectivity for patch 2 (cs1 = connectivity of spores from patch 1 to patch 2)
  #parset.f1[names(parset.f1[2])] <- cs.f 
  
  parset.f1[names(parset.f1[3])] <- cd.f # set the values of drift connectivity for patch 2 (cd2 = connectivity of drift from patch 1 to patch 2)
  #parset.f1[names(parset.f1[4])] <- cd.f 
  
#set the first upper and lower urchin density to test
lower <- 0
upper <- 60


while(upper-lower > 1*10^-5){#while the difference between the upper and lower bounds is greater than 10^-5
  
  mid = (upper + lower)/2#calculate the mid point
  
  # assign the urchin density
	#u <- mid
	
	#assign the par vals (with urchin density in both patches = mid and the parameter of interest equal to the jth element of par.vec)
  #parset.f <- c(parset.f1, u1 = mid, u2=mid)# add the two urchin densities to the parameter vector
  parset.f <- c(parset.f1, u1 = 0, u2=mid)# add the urchin densities to the parameter vector
  

	# initial conditions: low in focal patch
  #ic.low <- c(G1 = G0.l, J1= J0.l, A1= A0.l, G2 = G0.l, J2= J0.l, A2= A0.l)#initial conditions
  ic.low <- c(G1 = G0.h, J1= J0.h, A1= A0.h, G2 = G0.l, J2= J0.l, A2= A0.l)#initial conditions  
  
#simulate the model
  results.low <- ode(ic.low, times1, mod.fun2, parset.f, method = "lsodes")
  #save the A1 values
  #A.low <- results.low[ ,4]
  A.low <- results.low[ ,7] # adult kelp in patch 2

  Astar <- A.low[length(times1)]
 
  
  if(Astar > Athresh){#if A* for u=mid is greater than the cutoff for the high state (in high state)
    lower <- mid #the mid point is too low (since A decreases w/ increasing u), so mid is the new lower bound
  } else if (Astar < Athresh) {#if A* for u=mid is less than the cutoff (in low state)
    upper <- mid# the mid point is too high, so mid is the new upper bound
  } else {
    upper <- lower#if A*=thresh, then the mid point is the critical value, so stop the while loop by setting the upper bound equal to the lower bound
  } 
  
  #print(mid)
}

# the mid point at which the while loop ends is the ucrit value

lowerthresh[j] <- mid

}


# now get the upper threshold urchin density

#holding vector for the critical urchin densities for each level of connectivity
upperthresh <- NaN*par.vec

for(j in 1:length(par.vec)){
  
  # get the parameter set (without urchin densities)
  parset.f1 <- parsbase[1:27]

parset.f1[names(parset.f1[par.index])] <- par.vec[j] # change the element of parset.f that corresponds to the parameter of interest to the jth element of par.vec

  parset.f1[names(parset.f1[1])] <- cs.f # set the values of spore connectivity
  #parset.f1[names(parset.f1[2])] <- cs.f
  
  parset.f1[names(parset.f1[3])] <- cd.f # set the values of drift connectivity
  #parset.f1[names(parset.f1[4])] <- cd.f 
  

#set the first upper and lower urchin density to test
lower <- 0
upper <- 80


while(upper-lower > 1*10^-5){#while the difference between the upper and lower bounds is greater than 10^-5
  
  mid = (upper + lower)/2#calculate the mid point
  
  # assign the urchin density
	#u <- mid
	
	#assign the par vals (with urchin density in both patches = mid and the parameter of interest equal to the jth element of par.vec)
  parset.f <- c(parset.f1, u1 = 0, u2=mid)# add the two urchin densities to the parameter vector
  
	# initial conditions: high
  ic.high <- c(G1 = G0.h, J1= J0.h, A1= A0.h, G2 = G0.h, J2= J0.h, A2= A0.h)#initial conditions  
  
#simulate the model
  results.high <- ode(ic.high, times1, mod.fun2, parset.f, method = "lsodes")
  #save the A1 values
  #A.high <- results.high[ ,4]
  A.high <- results.high[ ,7]

  Astar <- A.high[length(times1)]
 
  
  if(Astar > Athresh){#if A* for u=mid is greater than the cutoff for the high state (in high state)
    lower <- mid #the mid point is too low (since A decreases w/ increasing u), so mid is the new lower bound
  } else if (Astar < Athresh) {#if A* for u=mid is less than the cutoff (in low state)
    upper <- mid# the mid point is too high, so mid is the new upper bound
  } else {
    upper <- lower#if A*=thresh, then the mid point is the critical value, so stop the while loop by setting the upper bound equal to the lower bound
  } 
  
  #print(mid)
}

# the mid point at which the while loop ends is the ucrit value

upperthresh[j] <- mid

}
  
  
  return(list(lowerthresh, upperthresh))
  
}


```



## simulations

Run the simulations; note this takes about 15 minutes

```{r}
#thresh.fun <- function(par.vec, par.index, cs.f, cd.f)

#parsbase <-  c(cs1=0, cs2=0, cd1=0, cd2=0, exts1=0, exts2=0, extd1=0, extd2=0, ls1, ls2, ld1, ld2, rho, rG, muG, rJ, muJ, K1, K2, muA, qG, qJ, g, p, d, gd, b, u1 = 0, u2=0)

tic()
# muG = parsbase[15]
muG.vals <- seq(from = 0.1*muG, to = 10*muG, length.out = 10)

muG.noc <- thresh.fun(muG.vals, 15, 0, 0) # par.vec = vector of muG values to test, muG is the 15 element of parsbase, here spore and drift connectivity = 0
muG.cs <- thresh.fun(muG.vals, 15, 0.2, 0) # par.vec = vector of muG values to test, muG is the 15 element of parsbase, spore connectivity = 0.2, drift conn = 0
muG.cd <- thresh.fun(muG.vals, 15, 0, 0.2) # par.vec = vector of muG values to test, muG is the 15 element of parsbase, spore connectivity = 0, drift conn = 0.2

# muJ = parsbase[17]
muJ.vals <- seq(from = 0.1*muJ, to = 10*muJ, length.out = 10)

muJ.noc <- thresh.fun(muJ.vals, 17, 0, 0) 
muJ.cs <- thresh.fun(muJ.vals, 17, 0.2, 0) 
muJ.cd <- thresh.fun(muJ.vals, 17, 0, 0.2) 

# rG = parsbase[14]
rG.vals <- seq(from = 0.1*rG, to = 10*rG, length.out = 10)

rG.noc <- thresh.fun(rG.vals, 14, 0, 0) 
rG.cs <- thresh.fun(rG.vals, 14, 0.2, 0) 
rG.cd <- thresh.fun(rG.vals, 14, 0, 0.2) 

# rJ = parsbase[16]
rJ.vals <- seq(from = 0.1*rJ, to = 10*rJ, length.out = 10)

rJ.noc <- thresh.fun(rJ.vals, 16, 0, 0) 
rJ.cs <- thresh.fun(rJ.vals, 16, 0.2, 0) 
rJ.cd <- thresh.fun(rJ.vals, 16, 0, 0.2) 

# rho = parsbase[13]
rho.vals <- seq(from = 0.1*rho, to = 10*rho, length.out = 10)

rho.noc <- thresh.fun(rho.vals, 13, 0, 0) 
rho.cs <- thresh.fun(rho.vals, 13, 0.2, 0) 
rho.cd <- thresh.fun(rho.vals, 13, 0, 0.2) 

# d = parsbase[25]
d.vals <- seq(from = 0.1*d, to = 0.12, length.out = 10) #0.12 is max observed in the data

d.noc <- thresh.fun(d.vals, 25, 0, 0) 
d.cs <- thresh.fun(d.vals, 25, 0.2, 0) 
d.cd <- thresh.fun(d.vals, 25, 0, 0.2) 

# b = parsbase[27]
b.vals <- seq(from = 1, to = 30, length.out = 10) 

b.noc <- thresh.fun(b.vals, 27, 0, 0) 
b.cs <- thresh.fun(b.vals, 27, 0.2, 0) 
b.cd <- thresh.fun(b.vals, 27, 0, 0.2) 

# K = parsbase[19]
k.vals <- seq(from = 0.1, to = 5, length.out = 10) 

k.noc <- thresh.fun(k.vals, 19, 0, 0) 
k.cs <- thresh.fun(k.vals, 19, 0.2, 0) 
k.cd <- thresh.fun(k.vals, 19, 0, 0.2) 

# p = parsbase[24]
p.vals <- seq(from = 0.01, to = 1, length.out = 10) 

p.noc <- thresh.fun(p.vals, 24, 0, 0) 
p.cs <- thresh.fun(p.vals, 24, 0.2, 0) 
p.cd <- thresh.fun(p.vals, 24, 0, 0.2) 

toc() #947.868 sec elapsed


```


Plot the results
```{r}
highthresh.col <- "cornflowerblue"

lowthresh.col <- "coral1"

# lty vals
lty.noc <- 3
lty.cs <- 2
lty.cd <- 1

#layout(matrix(c(1, 5, 9, 2, 6,10, 3, 7, 10, 4, 8, 10), nrow = 3, ncol = 4), widths = c(1, 1), heights = c(1, 1))# fill by row (want top row to be 1, 2, 3, 4 and second row to be 5, 6, 7, 8)
#layout.show(10)# 10 b/c 10 plots total and want to show all of them

pdf("Parsensitivity.pdf")
par(mfrow = c(3, 2), oma = c(4, 4, 2, 1))
layout(matrix(c(1, 5, 9, 2, 6,10, 3, 7, 10, 4, 8, 10), nrow = 3, ncol = 4), widths = c(1, 1), heights = c(1, 1))
par(mar=c(1, 1, 2, 0.01))
# muG
plot(x = muG.vals, y =muG.noc[[1]], type = "l", col = lowthresh.col, ylim = c(0, 65), lwd = 2, xlab = NA, ylab = NA, las = 1, lty = lty.noc, yaxt = "n")
axis(side = 2, at = c(0, 20, 40, 60), labels = c(0, 20, 40, 60), las = 1)
lines(x = muG.vals, y =muG.noc[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.noc)
lines(x = muG.vals, y =muG.cs[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cs)
lines(x = muG.vals, y =muG.cd[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cd)
lines(x = muG.vals, y =muG.cs[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cs)
lines(x = muG.vals, y =muG.cd[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cd)
#points(x = muG, y = -1.9, pch = 17)
axis(side = 1, at = muG, labels = NA, tck = 0.03, lwd = 2.5)
mtext(side = 3, "Sensitivity of region of bistability to model parameters", cex = 1.1, adj = -0.4)# "a) muG"
mtext(side = 3, adj = 0.05, line = -1.4, expression("a)"~mu["G"]))# "a) muG"
#mtext("Threshold urchin density", side = 2, cex = 1, adj = 0.5, outer = TRUE, line = 1)
mtext(expression("Threshold urchin density (ind./m"^2*")"), side = 2, cex = 1, adj = 0.5, outer = TRUE, line = 1)
#muJ
plot(x = muJ.vals, y =muJ.noc[[1]], type = "l", col = lowthresh.col, ylim = c(0, 65), lwd = 2, xlab = NA, ylab = NA, las = 1, lty = lty.noc, yaxt = "n")
axis(side = 2, at = c(0, 20, 40, 60), labels = NA)
lines(x = muJ.vals, y =muJ.noc[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.noc)
lines(x = muJ.vals, y =muJ.cs[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cs)
lines(x = muJ.vals, y =muJ.cd[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cd)
lines(x = muJ.vals, y =muJ.cs[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cs)
lines(x = muJ.vals, y =muJ.cd[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cd)
#abline(v = muJ)
axis(side = 1, at = muJ, labels = NA, tck = 0.03, lwd = 2.5)
mtext(side = 3, adj = 0.05, line = -1.4, expression("b)"~mu["J"]))
#rG
plot(x = rG.vals, y =rG.noc[[1]], type = "l", col = lowthresh.col, ylim = c(0, 65), lwd = 2, xlab = NA, ylab = NA, las = 1, lty = lty.noc, yaxt = "n")
axis(side = 2, at = c(0, 20, 40, 60), labels = NA)
lines(x = rG.vals, y =rG.noc[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.noc)
lines(x = rG.vals, y =rG.cs[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cs)
lines(x = rG.vals, y =rG.cd[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cd)
lines(x = rG.vals, y =rG.cs[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cs)
lines(x = rG.vals, y =rG.cd[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cd)
#abline(v = rG)
axis(side = 1, at = rG, labels = NA, tck = 0.03, lwd = 2.5)
mtext(side = 3, adj = 0.05, line = -1.4, expression("c)"~r["G"]))#"c) rG"
#rJ
plot(x = rJ.vals, y =rJ.noc[[1]], type = "l", col = lowthresh.col, ylim = c(0, 65), lwd = 2, xlab = NA, ylab = NA, las = 1, lty = lty.noc, yaxt = "n")
axis(side = 2, at = c(0, 20, 40, 60), labels = NA)
lines(x = rJ.vals, y =rJ.noc[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.noc)
lines(x = rJ.vals, y =rJ.cs[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cs)
lines(x = rJ.vals, y =rJ.cd[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cd)
lines(x = rJ.vals, y =rJ.cs[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cs)
lines(x = rJ.vals, y =rJ.cd[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cd)
#abline(v = rJ)
axis(side = 1, at = rJ, labels = NA, tck = 0.03, lwd = 2.5)
mtext(side = 3, adj = 0.05, line = -1.4, expression("d)"~r["J"]))#"d) rJ"
# rho
plot(x = rho.vals, y =rho.noc[[1]], type = "l", col = lowthresh.col, ylim = c(0, 65), lwd = 2, xlab = NA, ylab = NA, las = 1, lty = lty.noc, yaxt = "n")
axis(side = 2, at = c(0, 20, 40, 60), labels = c(0, 20, 40, 60), las = 1)
lines(x = rho.vals, y =rho.noc[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.noc)
lines(x = rho.vals, y =rho.cs[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cs)
lines(x = rho.vals, y =rho.cd[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cd)
lines(x = rho.vals, y =rho.cs[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cs)
lines(x = rho.vals, y =rho.cd[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cd)
#abline(v = rho)
axis(side = 1, at = rho, labels = NA, tck = 0.03, lwd = 2.5)
mtext(side = 3, adj = 0.05, line = -1.4, expression("e)"~rho~"(rho)")) #"f) rho"
# d
plot(x = d.vals, y =d.noc[[1]], type = "l", col = lowthresh.col, ylim = c(0, 65), lwd = 2, xlab = NA, ylab = NA, las = 1, lty = lty.noc, yaxt = "n")
axis(side = 2, at = c(0, 20, 40, 60), labels = NA)
lines(x = d.vals, y =d.noc[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.noc)
lines(x = d.vals, y =d.cs[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cs)
lines(x = d.vals, y =d.cd[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cd)
lines(x = d.vals, y =d.cs[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cs)
lines(x = d.vals, y =d.cd[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cd)
#abline(v = d)
axis(side = 1, at = d, labels = NA, tck = 0.03, lwd = 2.5)
mtext(side = 3, adj = 0.05, line = -1.2, "f) d")
# b
plot(x = b.vals, y =b.noc[[1]], type = "l", col = lowthresh.col, ylim = c(0, 65), lwd = 2, xlab = NA, ylab = NA, las = 1, lty = lty.noc, yaxt = "n")
axis(side = 2, at = c(0, 20, 40, 60), labels = NA)
lines(x = b.vals, y =b.noc[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.noc)
lines(x = b.vals, y =b.cs[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cs)
lines(x = b.vals, y =b.cd[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cd)
lines(x = b.vals, y =b.cs[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cs)
lines(x = b.vals, y =b.cd[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cd)
#abline(v = b)
axis(side = 1, at = b, labels = NA, tck = 0.03, lwd = 2.5)
mtext(side = 3, adj = 0.05, line = -1.2, "g) b")
# K
plot(x = k.vals, y =k.noc[[1]], type = "l", col = lowthresh.col, ylim = c(0, 65), lwd = 2, xlab = NA, ylab = NA, las = 1, lty = lty.noc, yaxt = "n")
axis(side = 2, at = c(0, 20, 40, 60), labels = NA)
lines(x = k.vals, y =k.noc[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.noc)
lines(x = k.vals, y =k.cs[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cs)
lines(x = k.vals, y =k.cd[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cd)
lines(x = k.vals, y =k.cs[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cs)
lines(x = k.vals, y =k.cd[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cd)
#abline(v = K2)
axis(side = 1, at = K2, labels = NA, tck = 0.03, lwd = 2.5)
mtext(side = 3, adj = 0.05, line = -1.2, "h) K")
# p
plot(x = p.vals, y =p.noc[[1]], type = "l", col = lowthresh.col, ylim = c(0, 65), lwd = 2, xlab = NA, ylab = NA, lty = lty.noc, las = 1, yaxt = "n")
axis(side = 2, at = c(0, 20, 40, 60), labels = c(0, 20, 40, 60), las = 1)
lines(x = p.vals, y =p.noc[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.noc)
lines(x = p.vals, y =p.cs[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cs)
lines(x = p.vals, y =p.cd[[1]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cd)
lines(x = p.vals, y =p.cs[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cs)
lines(x = p.vals, y =p.cd[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cd)
#abline(v = p)
axis(side = 1, at = p, labels = NA, tck = 0.03, lwd = 2.5)
mtext(side = 3, adj = 0.05, line = -1.2, "i) p")
mtext("Parameter value", side = 1, cex = 1, adj = 0.5, outer = TRUE, line = 1.5)
# legend
plot(0,type='n',axes=FALSE, ann = FALSE)# empty plot
legend(x="topleft", legend = c("lower", "upper"), col = c(lowthresh.col, highthresh.col), lwd = 2, ncol = 1, bty = "n", title="Bistability threshold", cex = 1.2)# , xpd = TRUE, inset = c(-0.5,-3.8), cex = 1.3 use xpd = TRUE and inset to have more control moving the legend position around
legend(x="top", legend = c("none", "spores only", "drift only"), lty = c(lty.noc, lty.cs, lty.cd), ncol = 1, bty = "n", title="External input", cex = 1.2)#,  xpd = TRUE, inset = c(-0.5,1.3)
# info on boxes in legends: https://stackoverflow.com/questions/15618079/legend-with-color-filling-and-shading-lines-in-base-r
dev.off()



```

# Fig S5

Show sensitivity of the region of bistability to simulataneous variation in all recruitment parameters (maturation and mortality rates of early life stages and spore production rate) 

Run the simulations:
```{r}
# set of values of "recruitment index" that multiplies the recruitment parameters
recruit.vals <- seq(from = 0.1, to = 10, length.out = 10)

# connectivity parameter sets
cs.vals <- c(0, 0.2, 0) # spore connectivity
cd.vals <- c(0, 0, 0.2) # drift connectivity

# make holding lists for the lower and upper urchin thresholds (each element will be a vector of threshold values across the recruitment par values for each set of connectivity par values)
recruit.lowt <- vector(mode="list", length=length(cs.vals))
recruit.hight <- vector(mode="list", length=length(cs.vals))


  # need an outer loop for the connectivity values

for(i in 1:length(cs.vals)){
  
  #holding vector for the critical urchin densities for each value of the parameter
lowerthresh.i <- NaN*recruit.vals

for(j in 1:length(recruit.vals)){
  
  # get the parameter set (without urchin densities)
  parset.ij1 <- parsbase[1:27]
  
  
parset.ij1[names(parset.ij1[13])] <- rho*recruit.vals[j] # change the element of parset.ij that corresponds to the parameter of interest to the jth element of the vector of values for that parameter. rho = element 13
  
parset.ij1[names(parset.ij1[14])] <- rG*recruit.vals[j] # rG = element 14

parset.ij1[names(parset.ij1[15])] <- muG*rev(recruit.vals)[j] # muG = element 15. NOTE: mortality is reversed b/c want high mortality to pair with low maturation values

parset.ij1[names(parset.ij1[16])] <- rJ*recruit.vals[j] # rJ = element 16

parset.ij1[names(parset.ij1[17])] <- muJ*rev(recruit.vals)[j] # muJ = element 17

  parset.ij1[names(parset.ij1[1])] <- cs.vals[i] # set the values of spore connectivity for patch 2 (cs1 = connectivity of spores from patch 1 to patch 2)
  #parset.ij1[names(parset.ij1[2])] <- cs.ij 
  
  parset.ij1[names(parset.ij1[3])] <- cd.vals[i] # set the values of drift connectivity for patch 2 (cd2 = connectivity of drift from patch 1 to patch 2)
  #parset.ij1[names(parset.ij1[4])] <- cd.ij 
  
#set the first upper and lower urchin density to test
lower <- 0
upper <- 60


while(upper-lower > 1*10^-5){#while the difference between the upper and lower bounds is greater than 10^-5
  
  mid = (upper + lower)/2#calculate the mid point
  
  # assign the urchin density
	#u <- mid
	
	#assign the par vals (with urchin density in both patches = mid and the parameter of interest equal to the jth element of par.vec)
  #parset.ij <- c(parset.ij1, u1 = mid, u2=mid)# add the two urchin densities to the parameter vector
  parset.ij <- c(parset.ij1, u1 = 0, u2=mid)# add the urchin densities to the parameter vector
  

	# initial conditions: low in focal patch
  #ic.low <- c(G1 = G0.l, J1= J0.l, A1= A0.l, G2 = G0.l, J2= J0.l, A2= A0.l)#initial conditions
  ic.low <- c(G1 = G0.h, J1= J0.h, A1= A0.h, G2 = G0.l, J2= J0.l, A2= A0.l)#initial conditions  
  
#simulate the model
  results.low <- ode(ic.low, times1, mod.fun2, parset.ij, method = "lsodes")
  #save the A1 values
  #A.low <- results.low[ ,4]
  A.low <- results.low[ ,7] # adult kelp in patch 2

  Astar <- A.low[length(times1)]
 
  
  if(Astar > Athresh){#if A* for u=mid is greater than the cutoff for the high state (in high state)
    lower <- mid #the mid point is too low (since A decreases w/ increasing u), so mid is the new lower bound
  } else if (Astar < Athresh) {#if A* for u=mid is less than the cutoff (in low state)
    upper <- mid# the mid point is too high, so mid is the new upper bound
  } else {
    upper <- lower#if A*=thresh, then the mid point is the critical value, so stop the while loop by setting the upper bound equal to the lower bound
  } 
  
  #print(mid)
}

# the mid point at which the while loop ends is the ucrit value

lowerthresh.i[j] <- mid

}


# now get the upper urchin threshold

#holding vector for the critical urchin densities for each level of connectivity
upperthresh.i <- NaN*recruit.vals

for(j in 1:length(recruit.vals)){
  
  # get the parameter set (without urchin densities)
  parset.ij1 <- parsbase[1:27]
  
  parset.ij1[names(parset.ij1[13])] <- rho*recruit.vals[j] # rho = element 13
  
parset.ij1[names(parset.ij1[14])] <- rG*recruit.vals[j] # rG = element 14

parset.ij1[names(parset.ij1[15])] <- muG*rev(recruit.vals)[j] # muG = element 15. NOTE: mortality is reversed b/c want high mortality to pair with low maturation values

parset.ij1[names(parset.ij1[16])] <- rJ*recruit.vals[j] # rJ = element 16

parset.ij1[names(parset.ij1[17])] <- muJ*rev(recruit.vals)[j] # muJ = element 17

  parset.ij1[names(parset.ij1[1])] <- cs.vals[i] # set the values of spore connectivity for patch 2 (cs1 = connectivity of spores from patch 1 to patch 2)
  #parset.ij1[names(parset.ij1[2])] <- cs.ij 
  
  parset.ij1[names(parset.ij1[3])] <- cd.vals[i] # set the values of drift connectivity for patch 2 (cd2 = connectivity of drift from patch 1 to patch 2)
  #parset.ij1[names(parset.ij1[4])] <- cd.ij 
  

#set the first upper and lower urchin density to test
lower <- 0
upper <- 80


while(upper-lower > 1*10^-5){#while the difference between the upper and lower bounds is greater than 10^-5
  
  mid = (upper + lower)/2#calculate the mid point
  
  # assign the urchin density
	#u <- mid
	
	#assign the par vals (with urchin density in both patches = mid and the parameter of interest equal to the jth element of par.vec)
  parset.ij <- c(parset.ij1, u1 = 0, u2=mid)# add the two urchin densities to the parameter vector
  
	# initial conditions: high
  ic.high <- c(G1 = G0.h, J1= J0.h, A1= A0.h, G2 = G0.h, J2= J0.h, A2= A0.h)#initial conditions  
  
#simulate the model
  results.high <- ode(ic.high, times1, mod.fun2, parset.ij, method = "lsodes")
  #save the A1 values
  #A.high <- results.high[ ,4]
  A.high <- results.high[ ,7]

  Astar <- A.high[length(times1)]
 
  
  if(Astar > Athresh){#if A* for u=mid is greater than the cutoff for the high state (in high state)
    lower <- mid #the mid point is too low (since A decreases w/ increasing u), so mid is the new lower bound
  } else if (Astar < Athresh) {#if A* for u=mid is less than the cutoff (in low state)
    upper <- mid# the mid point is too high, so mid is the new upper bound
  } else {
    upper <- lower#if A*=thresh, then the mid point is the critical value, so stop the while loop by setting the upper bound equal to the lower bound
  } 
  
  #print(mid)
}

# the mid point at which the while loop ends is the ucrit value

upperthresh.i[j] <- mid

}
  

# store the results for the ith connectivity values
recruit.lowt[[i]] <- lowerthresh.i
recruit.hight[[i]] <- upperthresh.i

  
} 




```

plot Fig. S5:

```{r}

pdf("Recuitsensitivity.pdf", width = 6, height = 6)
plot(x = recruit.vals, y =recruit.lowt[[1]], type = "l", col = lowthresh.col, ylim = c(0, 80), lwd = 2, xlab = NA, ylab = NA, las =1, lty = lty.noc)
mtext(side = 1, "Recruitment index", line = 2.5)
#mtext(side = 2, "Threshold urchin density", line = 2.5)
mtext(side = 2, expression("Threshold urchin density (ind./m"^2*")"), line = 2.5)
mtext(side = 3, "Effect of recruitment conditions on kelp stability", adj = 0)
lines(x = recruit.vals, y =recruit.hight[[1]], type = "l", col = highthresh.col, lwd = 2, lty = lty.noc)
lines(x = recruit.vals, y =recruit.lowt[[2]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cs)
lines(x = recruit.vals, y =recruit.lowt[[3]], type = "l", col = lowthresh.col, lwd = 2, lty = lty.cd)
lines(x = recruit.vals, y =recruit.hight[[2]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cs)
lines(x = recruit.vals, y =recruit.hight[[3]], type = "l", col = highthresh.col, lwd = 2, lty = lty.cd)
legend(x="topleft", legend = c("lower", "upper"), col = c(lowthresh.col, highthresh.col), lwd = 2, ncol = 1, bty = "n", title="Bistability threshold", cex = 1)# , xpd = TRUE, inset = c(-0.5,-3.8), cex = 1.3 use xpd = TRUE and inset to have more control moving the legend position around
legend(x="top", legend = c("none", "spores only", "drift only"), lty = c(lty.noc, lty.cs, lty.cd), ncol = 1, bty = "n", title="External input", cex = 1)
dev.off()

```


# Fig. S6
time series showing effect of constant and pulsed change in recruitment parameters on kelp population dynamics

simulations for constant recruitment conditions:

```{r}
#recruit.vals

#parsbase # no connectivity

# make timeseries with the 1st, 4th, 7th, and 10th elements of recruit.vals
#recruit.vals[c(1, 4, 7, 10)] # 3i-2

# make holding list to store the whole timeseries for each element of recruit.vals
Ats <- vector(mode="list", length=4)

for(i in 1:4){
  
  # get the parameter set (without urchin densities)
  parset.ij1 <- parsbase[1:27]
  
# change all the recruitment pars
parset.ij1[names(parset.ij1[13])] <- rho*recruit.vals[(3*i-2)] # change the element of parset.ij that corresponds to the parameter of interest to the jth element of the vector of values for that parameter. rho = element 13
  
parset.ij1[names(parset.ij1[14])] <- rG*recruit.vals[(3*i-2)] # rG = element 14

parset.ij1[names(parset.ij1[15])] <- muG*rev(recruit.vals)[(3*i-2)] # muG = element 15

parset.ij1[names(parset.ij1[16])] <- rJ*recruit.vals[(3*i-2)] # rJ = element 16

parset.ij1[names(parset.ij1[17])] <- muJ*rev(recruit.vals)[(3*i-2)] # muJ = element 17

  #make sure the urchin densities are 0
  parset.ij <- c(parset.ij1, u1 = 0, u2=0)# no urchins
  
	# initial conditions: low
  ic.low <- c(G1 = G0.l, J1= J0.l, A1= A0.l, G2 = G0.l, J2= J0.l, A2= A0.l)#initial conditions  
  
#simulate the model
  results.i <- ode(ic.low, times1, mod.fun2, parset.ij, method = "lsodes")
  #save the A1 values
  A.high <- results.i[ ,7]
  
  Ats[[i]] <- A.high
  
}


# add the default case
# initial conditions: low
  ic.low <- c(G1 = G0.l, J1= J0.l, A1= A0.l, G2 = G0.l, J2= J0.l, A2= A0.l)#initial conditions  
  
#simulate the model
  results.default <- ode(ic.low, times1, mod.fun2, parsbase, method = "lsodes")
  #save the A1 values
  Ats.default <- results.default[ ,7]


```


Recruitment pulses: add recruitment multiplier to the model function and allow its value to vary within a simulation

```{r}
mod.fun2r <- function (t, state2, params2r) {
  with(as.list(c(state2, params2r)), {
    
    Ir <- Irint(t)
    Im <- Imint(t)
    
     #grazing in patch 1 
    if(u1 == 0){
    graze1 <- 0
  } else{
    graze1 <- 1/(1+(1-p)/p*((extd1 + (1-ld1)*A1*b*d + ld2*cd2*b*d*A2)/(gd*u1))^2)
  }
     
     #grazing in patch 2 (focal patch)
     if(u2 == 0){
    graze2 <- 0
  } else{
    graze2 <- 1/(1+(1-p)/p*((extd2 + (1-ld2)*A2*b*d + ld1*cd1*b*d*A1)/(gd*u2))^2)
  }
    
    # ODE equations
  dG1dt <-  exts1 + (1-ls1)*b*Ir*rho*A1 + ls2*cs2*Ir*rho*b*A2 - Ir*rG*G1 - qG*g*u1*graze1*G1 - 1/Im*muG*G1*G1 #gametophytes
  dJ1dt <-  0.5*Ir*rG*G1- Ir*rJ*J1 - qJ*g*u1*graze1*J1 - 1/Im*muJ*J1*J1#juveniles
  dA1dt <-  Ir*rJ*J1*(1-A1/K1) - g*u1*graze1*A1 - muA*A1#adults
  
  dG2dt <-  exts2 + (1-ls2)*b*Ir*rho*A2 + ls1*cs1*Ir*rho*b*A1 - Ir*rG*G2 - qG*g*u2*graze2*G2 - 1/Im*muG*G2*G2 #gametophytes
  dJ2dt <-  0.5*Ir*rG*G2- Ir*rJ*J2 - qJ*g*u2*graze2*J2 - 1/Im*muJ*J2*J2#juveniles
  dA2dt <-  Ir*rJ*J2*(1-A2/K2) - g*u2*graze2*A2 - muA*A2#adults
  
  
  return(list(c(dG1dt, dJ1dt, dA1dt, dG2dt, dJ2dt, dA2dt), Irs = Ir, Ims = Im))
  })
    
}

# No Ir or Im in parameter set

# step function for the Ir and Im values
#tvec = vector of timesteps, Ixvec = empty vector to be filled in with Ix values, Ixstart.f=initial value of Ix, Ixnew.f = high value of Ix, tstart.rise.f = timepoint at which increase starts, tchange.f = length of time over which Ix is changing (determines slope/rate of change), duration.f = amount of time Ix is high
Ix.fun <- function(tvec, Ixvec, Ixstart.f, Ixnew.f, tstart.rise.f, tchange.f, duration.f){
  
  for(i in 1:length(tvec)){#for each timepoint in the times vector
  t <- tvec[i]# t = the current timepoint
  
  if(t <= tstart.rise.f){#if t is less than the day at which Ix starts to increase 
      Ixvec[i] <- Ixstart.f# Ix is its lower value
    } else if(t >= tstart.rise.f & t < tstart.rise.f + tchange.f){# if t is during the time when Ix is increasing
      Ixvec[i] <- Ixstart.f + (Ixnew.f - Ixstart.f)/tchange.f*(t-tstart.rise.f)
    } else if(t >= tstart.rise.f + tchange.f & t < tstart.rise.f + tchange.f + duration.f){
      Ixvec[i] <- Ixnew.f
    } else if(t >= tstart.rise.f + tchange.f + duration.f & t < tstart.rise.f + 2*tchange.f + duration.f){
      Ixvec[i] <- Ixnew.f + (Ixstart.f - Ixnew.f)/tchange.f*(t-(tstart.rise.f + tchange.f + duration.f))
    } else {
      Ixvec[i] <- Ixstart.f
    }
    
}

  return(Ixvec)
  
}

# get the timepoint values for the Ir and Im vectors (NOTE this needs to be the same time vector used in the model simulation)
Ixtimes <-  times1

# get the interpolated values
Irts.df <- data.frame(times = Ixtimes, Irval = rep(NA, length(Ixtimes))) 
Imts.df <- data.frame(times = Ixtimes, Imval = rep(NA, length(Ixtimes))) 
    
Irts.df$Irval <- Ix.fun(Irts.df$times, Irts.df$Irval, 1, 10, 5, 2, 7) # start at Ir = 1, go increase to Ir = 10 over a period of 2 days starting on day 5, stay high for 7 days before going back down to 1 over a period of 2 days

Imts.df$Imval <- Ix.fun(Imts.df$times, Imts.df$Imval, 1, 10, 5, 2, 7) # start at Im = 1, go increase to Im = 10 over a period of 2 days starting on day 5, stay high for 7 days before going back down to 1 over a period of 2 days


# get the interpolated Ir and Im values
Irint <- approxfun(Irts.df, rule = 2)
Imint <- approxfun(Imts.df, rule = 2)

```

run the simulation:

```{r}

results.IrIm <- ode(ic.low, times1, mod.fun2r, parsbase, method = "lsodes")
  #save the A1 values
  Ats.IrIm <- results.IrIm[ ,7]

```


Plot Fig. S6
```{r}

pdf("Recruitgrowth.pdf", height = 4, width = 10)
par(mfrow = c(1, 2), oma=c(2,4,1,1))
par(mai=c(0.3,0.15,0.15,0.01))
plot(x = times1, y = Ats[[1]], type = "l", xlab = NA, ylab =NA, ylim = c(0, 1), xlim = c(0,365), las = 1)
lines(x = times1, y = Ats[[2]], type = "l")
lines(x = times1, y = Ats[[3]], type = "l")
lines(x = times1, y = Ats[[4]], type = "l")
lines(x = times1, y = Ats.default, type = "l", col = "blue")
# add text next to each line
text(x = 225, y = 0.5, "default", col = "blue")
text(x = 115, y = 0.75, "3.4x")
text(x = 50, y = 0.9, "6.7x")
text(x = 20, y = 0.95, "10x")
text(x = 340, y = 0.05, "0.1x")
mtext(side = 3, line = 0, adj = 0, "a) Constant recruitment conditions")
mtext(side = 1, line=2, "Time (d)")
#mtext(side = 2, line=2.5, "Kelp density")
mtext(side = 2, line=2.5, expression("Kelp density (ind./m"^2*")"))
# note the default is inbetween 1 and 2, which seems a little slow but that's because this is for b = 7, if b was a higher value the dynamics would be faster because production would be higher, also there is no connectivity here

# recruitment pulse
plot(x = times1, y = Ats.IrIm, type = "l", xlab = NA, ylab =NA, ylim = c(0, 1), xlim = c(0,365), las = 1, yaxt = "n")
lines(x = times1, y = Ats.default, type = "l", col = "blue")
axis(side = 2, at = c(0, 0.2, 0.4, 0.6, 0.8, 1), labels = NA)
mtext(side = 3, line = 0, adj = 0, "b) Recruitment pulse")
mtext(side = 1, line=2, "Time (d)")
#mtext(side = 2, line=2.5, "Kelp density")
text(x = 225, y = 0.5, "default", col = "blue")
text(x = 150, y = 0.65, "10x (pulse)")
dev.off()

```

# Fig S4

Show the kelp dynamics in the cases in Fig. 3 where 1) local disturbance causes neighboring patch to go to the low state ("regional collapse") and 2) disturbed patch is rescued by the undisturbed patch ("rescue")

```{r}
# simulate storm as an event in the ode solver; make storm remove all kelp in patch 1 and have no effect on kelp in patch 2
storms.df <- data.frame(var = c("G1", "J1", "A1", "G2", "J2", "A2"), time = rep(1000, 6), value = c(0,0,0, 1, 1, 1), method=rep("mult", 6))#this can go directly into deSolve as an event

```

## regional collapse

```{r}

#parameters
params.TS.1 = c(cs1 = 0.25, cs2 = 0.25, cd1=0.25, cd2=0.25, exts1=0, exts2=0, extd1=0, extd2=0, ls1, ls2, ld1, ld2, rho, rG, muG, rJ, muJ, K1, K2, muA, qG, qJ, g, p, d, gd, b, u1 = 19, u2=19)

# initial conditions
xic.TS <- c(G1 = G0.h, J1= J0.h, A1= A0.h, G2 = G0.h, J2= J0.h, A2= A0.h)

#time
times.TS = seq(from = 0, to = 2000, length.out = 2000)

#run the model
results.TS.1 <- ode(xic.TS, times.TS, mod.fun2, params.TS.1, method = "lsodes", events = list(data = storms.df))#switched to lsodes from lsoda because the system was stiff (for high urchins, the end of the simulation was NA)
colnames(results.TS.1) = c("time", "G1", "J1", "A1", "G2", "J2", "A2")



```

## rescue


```{r}

#parameters
params.TS.2 = c(cs1 = 0.5, cs2 = 0.5, cd1=0.5, cd2=0.5, exts1=0, exts2=0, extd1=0, extd2=0, ls1, ls2, ld1, ld2, rho, rG, muG, rJ, muJ, K1, K2, muA, qG, qJ, g, p, d, gd, b, u1 = 19, u2=19)


#run the model
results.TS.2 <- ode(xic.TS, times.TS, mod.fun2, params.TS.2, method = "lsodes", events = list(data = storms.df))#switched to lsodes from lsoda because the system was stiff (for high urchins, the end of the simulation was NA)
colnames(results.TS.2) = c("time", "G1", "J1", "A1", "G2", "J2", "A2")



```

### plot
```{r}

# put together
pdf("TSdisturbance.pdf")
par(mfrow = c(2, 1), oma=c(1,1,1,0))
par(mai=c(0.8,1,0.1,0.01))
plot(x = results.TS.1[ ,"time"], y = results.TS.1[ ,"A1"], type = 'l', las = 1, lwd = 2, xlab = NA, ylab = NA, ylim = c(0, 0.8), xlim = c(800, 1500))
lines(x = results.TS.1[ ,"time"], y = results.TS.1[ ,"A2"], type = 'l', lwd = 2, lty = 2)
legend(x = "topright", legend = c("patch 1", "patch 2"), lty = c(1, 2), bty = "n", cex = 1.5, lwd = 2)
#mtext("a) Regional collapse (cs = cd = 0.25)", side = 3, adj = 0, cex = 1.5)
mtext(expression("a) Regional collapse ("* c["s"] *"="~c["d"]*"=0.25)"), side = 3, adj = 0, cex = 1.2)
#mtext(side = 2, "Kelp density", line = 2.5)
mtext(side = 2, line=2.5, expression("Kelp density (ind./m"^2*")"))
abline(v = 1000, col = "blue")

plot(x = results.TS.2[ ,"time"], y = results.TS.2[ ,"A1"], type = 'l', las = 1, lwd = 2, xlab = NA, ylab = NA, ylim = c(0, 0.8), xlim = c(800, 1500))
lines(x = results.TS.2[ ,"time"], y = results.TS.2[ ,"A2"], type = 'l', lwd = 2, lty = 2)
#mtext("b) Rescue (cs = cd = 0.5)", side = 3, adj = 0, cex = 1.5)
mtext(expression("b) Rescue ("* c["s"] *"="~c["d"]*"=0.5)"), side = 3, adj = 0, cex = 1.2)
#mtext(side = 2, "Kelp density", line = 2.5)
mtext(side = 2, line=2.5, expression("Kelp density (ind./m"^2*")"))
mtext(side = 1, "Time (d)", line = 2.5)
abline(v = 1000, col = "blue")
dev.off()


```








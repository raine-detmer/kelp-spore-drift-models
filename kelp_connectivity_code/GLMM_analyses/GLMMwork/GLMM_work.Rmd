---
title: "GLMM_work"
author: "Raine Detmer"
date: "4/6/2023"
output: html_document
---

README: Code for the GLMM analyses described in the main text and associated supplemental figures (Fig.s S9-S17)

# packages

```{r}
library("tidyverse")
library("lubridate")

library("lme4")
#packageVersion("lme4") #1.1.28
library("car")
library("DHARMa")

#for allFit
library("optimx")
library("dfoptim")

library("sjPlot")# for random effects qqplot

library("MuMIn")#for calculating AIC weights

library("ncf") # for checking spatial autocorrelation

library("tictoc") # to time how long code takes to run

library("gridExtra") # for exporting AIC table as image

```

# data

```{r}
# import the intermediate data that was formatted in "format_data.Rmd"
# the .. moves up one file path from the current one; the following code assumes a file structure of "name of github repo"/kelp_connectivity_code/GLMM_analyses/GLMMwork, where "name of github repo" also includes the "intermediate_data_output" folder
# benthic transect data
benthicdt <- read.csv("../../../intermediate_data_output/GLMM_data/benthic_data.csv") %>% dplyr::select(-X) # remove column with row number

# metapopulation patch data
patchdt <- read.csv("../../../intermediate_data_output/GLMM_data/patch_data.csv") %>% dplyr::select(-X) # remove column with row number

```

combine the data and prep for GLMM fitting
```{r}
# convert patch connectivity to 1 semester lag (see "GLMM_sensitivity.Rmd" for different lag times)
patchdt1Sfull <- patchdt %>% group_by(patch) %>% mutate_at(c(colnames(patchdt[4:9])), list(~ lag(.,n=1L, default = NA, order_by = year.sem))) %>% ungroup()

# join the patch and transect data
full_datalvals <-left_join(benthicdt, patchdt1Sfull, by = c("year", "semester", "year.sem","patch")) %>% filter(is.na(patch_area)==F) %>% mutate(patch = as.factor(patch), transect_id = as.factor(transect_id))%>% filter(is.na(patch_conn0.9)==F, is.na(kelp_dens)==F)


# set threshold kelp density separating high and low states (calculated in "format_data.Rmd")
thresh <- 0.05

#function to log + 1 transform variables
log1fun <- function(x){
log_transformed <- log(x+1)
return(log_transformed)
}

# log transform all predictor variables, turn kelp density into kelp_status (response variable), and turn all random effects into factors
full_data_for_mod <- full_datalvals %>% mutate_at(c(colnames(full_datalvals[c(6,15:20)])), list(~ log1fun(.))) %>% mutate(patch_area = log(patch_area)) %>% mutate(kelp_status=if_else(is.na(kelp_dens)==T, as.numeric(NA), if_else(kelp_dens>thresh, 1, 0)))%>% mutate(fyear = as.factor(year), patch = as.factor(patch), transect_id = as.factor(transect_id)) 
# NOTE: using mutate_at doesn't change the names of the columns, even though they are now log transformed


```

# Full data

GLMM analyses using the full dataset created above

## data prep

```{r}
# get the subset of data with the connectivities for loss rate = 0.9
datalvals0.9 <- full_data_for_mod# make new dataframe 

datalvals0.9[ ,26] <- full_data_for_mod[, 14+5]#add a new column with the patch conn values for loss rate = 0.9 (column 19)

colnames(datalvals0.9)[26] <- "patch_conn"#name this column patch_conn; note this is called patch_conn but it is really log transformed (same with urchin_dens and patch_area)

View(datalvals0.9)

```

## fitting

random effects selection

```{r}

#head(datalvals0.9)

# fit full model with patch, transect, and year as random effects
mod9r3 <- glmer(kelp_status ~ urchin_dens*patch_conn + patch_area  + (1|patch) + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit)) # model is singular

summary(mod9r3) # patch has tiny variance

# remove random effect of patch and refit
mod9r2 <- glmer(kelp_status ~ urchin_dens*patch_conn + patch_area  + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))

#compare estimates with and without patch random effect
sapply(list(mod9r3, mod9r2), logLik)
sapply(list(mod9r3, mod9r2), fixef)
sapply(list(mod9r3, mod9r2), function(x) unlist(VarCorr(x)))
#failed to converge with random effect of patch, but estimates with and without patch are basically the same

```

fixed effects selection

```{r}
#fit all the models
mod9f0 <- glmer(kelp_status ~ (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))#null model (no fixed effects)

mod9fU <- glmer(kelp_status ~ urchin_dens + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))#urchins only

mod9fC <- glmer(kelp_status ~ patch_conn + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))#connectivity only

mod9fA <- glmer(kelp_status ~ patch_area + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))# patch area only

mod9fUC <- glmer(kelp_status ~ urchin_dens + patch_conn + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))# urchins and connectivity

mod9fUA <- glmer(kelp_status ~ urchin_dens + patch_area + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))#urchins and patch area

mod9fCA <- glmer(kelp_status ~ patch_conn + patch_area  + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))# connectivity and patch area

mod9fUCA <- glmer(kelp_status ~ urchin_dens + patch_conn + patch_area  + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit)) #urchins, connectivity, and patch area

mod9fUxC <- glmer(kelp_status ~ urchin_dens*patch_conn + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))# urchin x connectivity

mod9fUxCA <- glmer(kelp_status ~ urchin_dens*patch_conn + patch_area  + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))# urchin x connectivity and patch area

```


```{r}
# aside: check fitting without log transformation
#full_data_for_mod_nL <- full_datalvals %>% mutate(kelp_status=if_else(is.na(kelp_dens)==T, as.numeric(NA), if_else(kelp_dens>thresh, 1, 0)))%>% mutate(fyear = as.factor(year), patch = as.factor(patch), transect_id = as.factor(transect_id)) 

# log transform all fixed effects except urchin densities 
#full_data_for_mod_nL <- full_datalvals %>% mutate_at(c(colnames(full_datalvals[c(15:20)])), list(~ log1fun(.))) %>% mutate(kelp_status=if_else(is.na(kelp_dens)==T, as.numeric(NA), if_else(kelp_dens>thresh, 1, 0)))%>% mutate(fyear = as.factor(year), patch = as.factor(patch), transect_id = as.factor(transect_id)) %>% mutate(patch_area = log(patch_area))

# get the subset of data with the connectivities for loss rate = 0.9
#datalvals0.9_nL <- full_data_for_mod_nL# make new dataframe 
#datalvals0.9_nL[ ,26] <- full_data_for_mod_nL[, 14+5]#add a new column with the patch conn values for loss rate = 0.9 (column 19)
#colnames(datalvals0.9_nL)[26] <- "patch_conn"#name this column patch_conn; note this is called patch_conn but it is really log transformed (same with urchin_dens and patch_area)


#mod9r3_nL <- glmer(kelp_status ~ urchin_dens*patch_conn + patch_area  + (1|patch) + (1|transect_id) + (1|fyear), data=datalvals0.9_nL, family = binomial(link=logit)) # not log transforming any fixed effects gives error: "PIRLS step-halvings failed to reduce deviance in pwrssUpdate". Log transforming all fixed effects except urchin density gives convergence failure and error "arning: Model is nearly unidentifiable: large eigenvalue ratio"

# try removing patch
#mod9r2_nL <- glmer(kelp_status ~ urchin_dens*patch_conn + patch_area  + (1|transect_id) + (1|fyear), data=datalvals0.9_nL, family = binomial(link=logit))# not log transforming any fixed effects gives error: "PIRLS step-halvings failed to reduce deviance in pwrssUpdate". Log transforming all fixed effects except urchin density gives convergence failure and error "arning: Model is nearly unidentifiable: large eigenvalue ratio"

```

```{r}
#get AICs and weights

#make function to get the deltas
deltaAIC.fun <- function(AICs, AIC.min){
  
  deltas <- AICs - AIC.min
  
  return(deltas)
  
}

mod9_AICs <- AIC(mod9f0, mod9fU, mod9fC, mod9fA, mod9fUC, mod9fUA, mod9fCA, mod9fUCA, mod9fUxC, mod9fUxCA)

#get the delta AIC values
mod9_deltas <- deltaAIC.fun(mod9_AICs[, 2], min(mod9_AICs[, 2]))

#get the weights
mod9_weights <- as.vector(round(Weights(mod9_AICs[, 2]), 3))

# add the delta AICs and weights to the AIC dataframe
mod9_AICs$delta <- mod9_deltas
mod9_AICs$weights <- mod9_weights

mod9_AICs <- mod9_AICs[order(mod9_AICs$AIC), ] 

#mod9_AICs

# rename rows
mod9_AICs2 <- mod9_AICs
rownames(mod9_AICs2) <- NULL
rownames(mod9_AICs2) <- c("UCA", "UxCA", "UC", "UxC", "UA", "U", "CA", "C", "A", "0")

#mod9_AICs2

# round for displaying the table
mod9_AICs2 <- mod9_AICs2 %>% mutate(AIC = round(AIC, 1), delta = round(delta, 1), weights = round(weights, 1))

# save the table of AIC values
pdf("AICGLMMtable.pdf")#, height = 50*nrow(mod_AICs2), width = 200*ncol(mod_AICs2)
grid.table(mod9_AICs2, theme = ttheme_minimal(core = list(bg_params=list(fill=rep(NA,11), col="black")))) # ingridExtra package
dev.off()

# information on making tables: https://cran.r-project.org/web/packages/gridExtra/vignettes/tableGrob.html
# https://cyancey95.github.io/CompBiol_2018/gridExtraPresentation.html

#grid.table(mod9_AICs2, theme = ttheme_minimal(core = list(bg_params=list(fill=rep(NA,11), col="black")))) # ingridExtra package

```

refit the best-fitting models with patch to check the coefficients don't differ

```{r}
mod9fUCAp <- glmer(kelp_status ~ urchin_dens + patch_conn + patch_area + (1|patch)  + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit)) #urchins, connectivity, and patch area, singular

mod9fUxCAp <- glmer(kelp_status ~ urchin_dens*patch_conn + patch_area + (1|patch) + (1|transect_id) + (1|fyear), data=datalvals0.9, family = binomial(link=logit))# urchin x connectivity and patch area, model is singular


#check that the estimates with and without patch random effect don't differ
sapply(list(mod9fUCA, mod9fUCAp), logLik)
sapply(list(mod9fUCA, mod9fUCAp), fixef)
sapply(list(mod9fUCA, mod9fUCAp), function(x) unlist(VarCorr(x)))

sapply(list(mod9fUxCA, mod9fUxCAp), logLik)
sapply(list(mod9fUxCA, mod9fUxCAp), fixef)
sapply(list(mod9fUxCA, mod9fUxCAp), function(x) unlist(VarCorr(x)))

AIC(mod9fUCAp, mod9fUxCAp)#AIC order also didn't change

```

## check assumptions

check that the best-fitting model meets GLMM assumptions

### vif

use vif to check for collinearity
```{r}
vif(mod9fUCA)# these are all less than 1.5
```


### residuals

```{r}
#R1 <- resid(fullmod, type = "pearson") 
#F1 <- fitted(fullmod)

#look at partial residuals vs predictors
# predictors vs partial residuals
# make function to compute partial residuals (formula from Zuur et al. 2009, pg 489)
partial_res.fn <- function(yval, phat, predval, betaval){
  r_par <- (yval-phat)/(phat*(1-phat)) + predval*betaval#Zuur page 489 (eqn. 21.5). yval = observed value (0 or 1), phat = predicted probability, predval = predictor/covariate value, betaval = estimated coeff. for the covariate from the fitted model
}

plot(x=datalvals0.9$urchin_dens, y=partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$urchin_dens, fixef(mod9fUCA)[2]), xlab = "log(urchin density)", ylab = "Partial residuals")#ylim = c(-10, 10)
lines(lowess(datalvals0.9$urchin_dens, partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$urchin_dens, fixef(mod9fUCA)[2])), col='red')
text(x =datalvals0.9$urchin_dens, y = partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$urchin_dens, fixef(mod9fUCA)[2]), labels = rownames(datalvals0.9),  cex=0.9)

plot(x=datalvals0.9$patch_conn, y=partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_conn, fixef(mod9fUCA)[3]), xlab = "log(patch connectivity)", ylab = "Partial residuals")#ylim = c(-10, 10)
lines(lowess(datalvals0.9$patch_conn, partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_conn, fixef(mod9fUCA)[3])), col='red')
text(x =datalvals0.9$patch_conn, y = partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_conn, fixef(mod9fUCA)[3]), labels = rownames(datalvals0.9),  cex=0.9)

plot(x=datalvals0.9$patch_area, y=partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4]), xlab = "log(patch area)", ylab = "Partial residuals")#ylim = c(-10, 10)
lines(lowess(datalvals0.9$patch_area, partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4])), col='red')
text(x =datalvals0.9$patch_area, y = partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4]), labels = rownames(datalvals0.9),  cex=0.9)

# make the points transparent to better read the point labels
plot(x=datalvals0.9$patch_area, y=partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4]), xlab = "log(patch area)", ylab = "Partial residuals", pch = 16, col = adjustcolor("gray", alpha.f=0.01))#ylim = c(-10, 10)
lines(lowess(datalvals0.9$patch_area, partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4])), col='red')
text(x =datalvals0.9$patch_area, y = partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4]), labels = rownames(datalvals0.9),  cex=0.9)

# check the outliers
datalvals0.9[c(144, 176, 177, 179),]# all the outliers are cases where there were no urchins, low kelp, and high connectivity

#plot with same y-axis scales
plot(x=datalvals0.9$urchin_dens, y=partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$urchin_dens, fixef(mod9fUCA)[2]), xlab = "log(urchin density)", ylab = "Partial residuals", ylim = c(-150, 20))#ylim = c(-10, 10)
lines(lowess(datalvals0.9$urchin_dens, partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$urchin_dens, fixef(mod9fUCA)[2])), col='red')
#text(x =datalvals0.9$urchin_dens, y = partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$urchin_dens, fixef(mod9fUCA)[2]), labels = rownames(datalvals0.9),  cex=0.9)

plot(x=datalvals0.9$patch_conn, y=partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_conn, fixef(mod9fUCA)[3]), xlab = "log(patch connectivity)", ylab = "Partial residuals", ylim = c(-150, 20))#ylim = c(-10, 10)
lines(lowess(datalvals0.9$patch_conn, partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_conn, fixef(mod9fUCA)[3])), col='red')
#text(x =datalvals0.9$patch_conn, y = partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_conn, fixef(mod9fUCA)[3]), labels = rownames(datalvals0.9),  cex=0.9)

plot(x=datalvals0.9$patch_area, y=partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4]), xlab = "log(patch area)", ylab = "Partial residuals", ylim = c(-150, 20))#ylim = c(-10, 10)
lines(lowess(datalvals0.9$patch_area, partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4])), col='red')
#text(x =datalvals0.9$patch_area, y = partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4]), labels = rownames(datalvals0.9),  cex=0.9)





#check residuals using DHARMa package
mod9fUCA_simres <- simulateResiduals(mod9fUCA)
plot(mod9fUCA_simres)
# note DHARMa is excluding RE estimates in the predictions when plotting res ~ pred. See here: https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html#general-remarks-on-interperting-residual-patterns-and-tests

```

### Fig. S11

make figure S11 (predictors vs. partial residuals for the best-fitting GLMM fit to the full dataset)
```{r}
pdf("GLMMpartialres.pdf", height = 7/2.5)# default height and width are both 7
par(mfrow = c(1, 3), oma = c(3.5, 4, 2, 1))
layout(matrix(c(1, 2, 3), nrow = 1, ncol = 3), widths = rep.int(1, 3), heights = rep.int(1, 1))
par(mar=c(0.05, 0, 0, 0.5))
plot(x=datalvals0.9$urchin_dens, y=partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$urchin_dens, fixef(mod9fUCA)[2]), xlab = NA, ylab = NA, ylim = c(-100, 20), pch = 16, yaxt = "n")#ylim = c(-10, 10)
lines(lowess(datalvals0.9$urchin_dens, partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$urchin_dens, fixef(mod9fUCA)[2])), col='blue')
axis(side = 2, at = c(-80, -40, 0), las = 1)
mtext(side = 1, "Urchin density (log scale)", line = 2.5, cex = 0.8)
mtext(side = 2, "Partial residuals", line = 2.5, cex = 0.8)
mtext(side = 3, "a) Urchin density", adj = 0)

plot(x=datalvals0.9$patch_conn, y=partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_conn, fixef(mod9fUCA)[3]), xlab = NA, ylab = NA, ylim = c(-100, 20), yaxt = "n", pch = 16)#ylim = c(-10, 10)
lines(lowess(datalvals0.9$patch_conn, partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_conn, fixef(mod9fUCA)[3])), col='blue')
axis(side = 2, at = c(-80, -40, 0), NA)
mtext(side = 1, "Patch connectivity (log scale)", line = 2.5, cex = 0.8)
#mtext(side = 2, "Partial residuals", line = 2.5)
mtext(side = 3, "b) Patch connectivity", adj = 0)

plot(x=datalvals0.9$patch_area, y=partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4]), xlab = NA, ylab = NA, ylim = c(-100, 20), yaxt = "n", pch = 16)#ylim = c(-10, 10)
lines(lowess(datalvals0.9$patch_area, partial_res.fn(datalvals0.9$kelp_status, fitted(mod9fUCA), datalvals0.9$patch_area, fixef(mod9fUCA)[4])), col='blue')
axis(side = 2, at = c(-80, -40, 0), NA)
mtext(side = 1, "Patch area (log scale)", line = 2.5, cex = 0.8)
#mtext(side = 2, "Partial residuals", line = 2.5)
mtext(side = 3, "c) Patch area", adj = 0)
dev.off()



```

### random effects

look at qq plot to check that the random effects (transect and year) are normally distributed 


```{r}
#uses sjPlot package
#type = "diag": For generalized linear mixed models, returns the QQ-plot for random effects.

plot_model(mod9fUCA, type = "diag", colors = "bw")[1]#transects

plot_model(mod9fUCA, type = "diag")[2]#years

get_model_data(mod9fUCA, type = "diag")[1]

```

### Fig. S9

plot Fig. S9
```{r}
# remake these in base R
# get the data used to make the default quantile plots
yearqq <- as.data.frame(get_model_data(mod9fUCA, type = "diag")[2])

# get the linear model and condidence intervals
yearlm <- lm(fyear.y~fyear.nQQ, data = yearqq)
yearx <- data.frame(fyear.nQQ=yearqq$fyear.nQQ)# newdata for predict()
yearpred <- data.frame(predict(yearlm,yearx, interval = "confidence"))# get the predictions and CIs

# repeat for transect
transect_idqq <- as.data.frame(get_model_data(mod9fUCA, type = "diag")[1])

transect_idlm <- lm(transect_id.y~transect_id.nQQ, data = transect_idqq)
transect_idx <- data.frame(transect_id.nQQ=transect_idqq$transect_id.nQQ)# newdata for predict()
transect_idpred <- data.frame(predict(transect_idlm,transect_idx, interval = "confidence"))# get the predictions and CIs


pdf("GLMMreffqq.pdf", height = 7/2.5)# default height and width are both 7
par(mfrow = c(1, 2), oma = c(3.5, 4, 2, 1))
par(mar=c(0.01, 1.2, 0, 1))
plot(x = transect_idqq$transect_id.nQQ, y = transect_idqq$transect_id.y, ylim = c(-4.5, 4), pch = 16, xlab = NA, ylab = NA, las = 1)
lines(x = transect_idx$transect_id.nQQ, y = transect_idpred$fit, type = "l")
polygon(x = c(transect_idqq$transect_id.nQQ, rev(transect_idqq$transect_id.nQQ)), y = c(transect_idpred$lwr, rev(transect_idpred$upr)), border = NA, col = adjustcolor("gray80", alpha.f = 0.6))
lines(x = transect_idx$transect_id.nQQ, y = transect_idpred$fit, type = "l")
lines(x = transect_idqq$transect_id.nQQ, y = transect_idqq$transect_id.y, pch = 16, type = "p") # repeat the first part of the plot so it is above the linear regression ribbon
for(i in 1:length(transect_idqq$transect_id.nQQ)){
  arrows(transect_idqq$transect_id.nQQ[i], transect_idqq$transect_id.conf.low[i], transect_idqq$transect_id.nQQ[i], transect_idqq$transect_id.conf.high[i], length=0, angle=90, code=3) # length = 0 means no arrowhead, code = 3 would make flat arrowhead if length > 0
}
mtext(side = 1, "Standard normal quantiles", line = 2.5, cex = 0.8)
mtext(side = 2, "Random effect quantiles", line = 2.5, cex = 0.8)
mtext(side = 3, "a) Transect", adj = 0)

plot(x = yearqq$fyear.nQQ, y = yearqq$fyear.y, ylim = c(-2, 2), pch = 16, xlab = NA, ylab = NA, las = 1, xaxt = "n")
axis(side = 1, at = c(-1, 0, 1))
lines(x = yearx$fyear.nQQ, y = yearpred$fit, type = "l")
polygon(x = c(yearqq$fyear.nQQ, rev(yearqq$fyear.nQQ)), y = c(yearpred$lwr, rev(yearpred$upr)), border = NA, col = adjustcolor("gray80", alpha.f = 0.6))
lines(x = yearx$fyear.nQQ, y = yearpred$fit, type = "l")
lines(x = yearqq$fyear.nQQ, y = yearqq$fyear.y, pch = 16, type = "p") # repeat the first part of the plot so it is above the linear regression ribbon
for(i in 1:length(yearqq$fyear.nQQ)){
  arrows(yearqq$fyear.nQQ[i], yearqq$fyear.conf.low[i], yearqq$fyear.nQQ[i], yearqq$fyear.conf.high[i], length=0, angle=90, code=3) # length = 0 means no arrowhead, code = 3 would make flat arrowhead if length > 0
}
mtext(side = 1, "Standard normal quantiles", line = 2.5, cex = 0.8)
#mtext(side = 2, "Random effect quantiles", line = 2.5)
mtext(side = 3, "b) Year", adj = 0)
dev.off()

```


### autocorrelation

temporal

```{r}
#get the acf values for the residuals as a vector for each transect, then put all these together, then get the mean for each lag, and for each transect get the number of ACF values greater than the CIs

transect_ids <- as.vector(unique(datalvals0.9$transect_id))#all the transect_ids
#empty matrices for the acf and pacf values
mod9fUCA_resid_acf <- matrix(NA, 11, length(transect_ids))#max is 11 years
mod9fUCA_resid_pacf <- matrix(NA, 10, length(transect_ids))#pacf is one less than acf

#empty vectors for number of acf and pacf values outside of confidence intervals
mod9fUCA_sig_res_acf <- rep(NA, length(transect_ids))
mod9fUCA_sig_res_pacf <- rep(NA, length(transect_ids))

for(i in 1:length(transect_ids)){#for each transect
  temp_data1 <- resid(mod9fUCA, type = "pearson")[which(datalvals0.9$transect_id==transect_ids[i])]#subset out the ith transect
  temp_data2 <- temp_data1[order(datalvals0.9[which(datalvals0.9$transect_id==transect_ids[i]), ]$year)] #order the observations by year
  
  n_obs <- length(temp_data2)#number of years transect was monitored
  
  #get the acf and pacf values
  mod9fUCA_resid_acf[1:n_obs, i] <- as.vector(acf(temp_data2, plot=F)$acf)
  
  mod9fUCA_resid_pacf[1:(n_obs-1), i] <- as.vector(pacf(temp_data2, plot=F)$acf)
  
  #get the number that are outside confidence intervals
  mod9fUCA_sig_res_acf[i] <- length(which(abs(mod9fUCA_resid_acf[ ,i]) > qnorm((1 + 0.95)/2)/sqrt(n_obs)))
  
  mod9fUCA_sig_res_pacf[i] <- length(which(abs(mod9fUCA_resid_pacf[ ,i]) > qnorm((1 + 0.95)/2)/sqrt(n_obs)))
  
}


which(mod9fUCA_sig_res_acf>1)# none are outside the confidence intervals (no significant temporal autocorrelation)
#acf(resid(mod9fUCA, type = "pearson")[which(datalvals0.9$transect_id==transect_ids[37])], plot=T)

which(mod9fUCA_sig_res_pacf>1)


#plot the mean acfs
barplot(apply(mod9fUCA_resid_acf, 1, function(x) mean(x, na.rm=T)), ylim = c(-0.4, 1), xlab="Time lag (yrs)", ylab="mean ACF", main="Temporal autocorrelation plot for residuals")
abline(h=0)
#axis(side=1, at=c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11), labels=c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10),las=0, cex.axis=1)


```

spatial

```{r}
# first get the coordinates of the transects

# SBC LTER coordinates
# Package ID: knb-lter-sbc.43.10 Cataloging System:https://pasta.edirepository.org.
# Data set title: SBC LTER: Reef: Kelp Forest Community Dynamics: Transect depth data.
# Data set creator:    - Santa Barbara Coastal LTER 
# Data set creator:  Daniel C Reed -  
# Data set creator:  Robert J Miller -  
# Contact:    - Information Manager, Santa Barbara Coastal LTER   - sbclter@msi.ucsb.edu
# Stylesheet v2.11 for metadata conversion into program: John H. Porter, Univ. Virginia, jporter@virginia.edu 
                   
sbc_coords0 <-read.csv("https://pasta.lternet.edu/package/data/eml/knb-lter-sbc/43/10/07675f89d4197afb4b682b3d73699fac",header=F ,skip=1 ,sep=","  ,quot='"', col.names=c("SITE", "TRANSECT","DEPTH_MLLW_M", "SD_DEPTH", "CV_DEPTH", "LATITUDE", "LONGITUDE", "SITE_NAME"), check.names=TRUE)

# transects that were added later:
# Package ID: knb-lter-sbc.44.9 Cataloging System:https://pasta.edirepository.org.
# Data set title: SBC LTER: Long-term experiment: Kelp Removal: Transect depth data .
# Data set creator:    - Santa Barbara Coastal LTER 
# Data set creator:  Daniel C Reed -  
# Data set creator:  Robert J Miller -  
# Contact:    - Information Manager, Santa Barbara Coastal LTER   - sbclter@msi.ucsb.edu
# Stylesheet v2.11 for metadata conversion into program: John H. Porter, Univ. Virginia, jporter@virginia.edu 

sbc_coords_new0 <-read.csv("https://pasta.lternet.edu/package/data/eml/knb-lter-sbc/44/9/b33eb7e93b097b92adc48bd802451fb4",header=F ,skip=1,sep="," ,quot='"', col.names=c( "SITE", "TRANSECT","DEPTH_MLLW_M", "SD_DEPTH", "CV_DEPTH", "LATITUDE", "LONGITUDE", "SITE_NAME"), check.names=TRUE)

sbc_coords1 <- rbind(sbc_coords0, sbc_coords_new0) %>% mutate(site.trans = paste(SITE, TRANSECT, sep = ".")) %>% dplyr::select(SITE, TRANSECT, LATITUDE, LONGITUDE, site.trans) %>% rename(Site = SITE, Transect = TRANSECT, Latitude = LATITUDE, Longitude = LONGITUDE) %>% dplyr::select(-Site, -Transect) %>% arrange(site.trans) %>% distinct()# remove duplicates (transects in both data sets)

# CINP KFMP coordinates (from Table 1 of Kushner et al. 2013; http://dx.doi.org/10.1890/13-0562.1)
kfm_coords0 <- read.csv("https://esapubs.org/archive/ecol/E094/245/Table1_Monitoring_sites.csv")

kfm_coords1 <- kfm_coords0 %>% dplyr::select(Site, Latitude__Deg_N_, Longitude__Deg_W_) %>% mutate(Site = as.factor(Site)) %>% rename(site_name = Site, Latitude = Latitude__Deg_N_, Longitude = Longitude__Deg_W_)

```

```{r}
#info here: https://search.r-project.org/CRAN/refmans/ncf/html/spline.correlog.html
#z = vector of length n or matrix of dimension n x p representing p observation at each location.

# make an nx11 matrix where each row is a location and each column is a year (and there will be some NAs since not all locations were monitored in each year)

sbc_coords2 <- left_join(sbc_coords1, unique(datalvals0.9[ ,c(3,5)]), by = "site.trans") %>% filter(is.na(transect_id)==F) %>% dplyr::select(-site.trans)#to just get the site.trans and transect_id matches from datalvals0.9, select just these two columns and use unique(). Also filter out the cases where transect_id = NA (transects that aren't in the datalvals0.9 dataset)

kfm_coords2 <- left_join(kfm_coords1, unique(datalvals0.9[ ,c(3,4)]), by = "site_name") %>% filter(is.na(transect_id)==F) %>% dplyr::select(-site_name)#to just get the site_name and transect_id matches from datalvals0.9, select just these two columns and use unique()


#combine together
trans_coords <- rbind(sbc_coords2,kfm_coords2)

#get data frame with just the locations (lat, lon), observation (kelp status), and year and use spread to make each year its own column
#first add the transect lat and long and model residuals to the data frame
#head(datalvals0.9) # col 3 = transect_id, col 8 = year
datalvals0.9_res <- left_join(datalvals0.9[,c(3,8)], trans_coords, by = "transect_id") #%>% dplyr::select(Latitude, Longitude, year)
datalvals0.9_res$UCAr <- resid(mod9fUCA, type = "pearson")

#View(datalvals0.9_res)# just want latitude, longitude, year, and residual columns 
wide_datalvals0.9_res1 <- datalvals0.9_res[ ,c(2, 3:5)] %>% spread(year, UCAr)
#View(wide_datalvals0.9_res1)

# compute splinecorrelogram with transect coords
Correlog_res1 <- spline.correlog(x = wide_datalvals0.9_res1$Longitude,
y = wide_datalvals0.9_res1$Latitude,
z = as.matrix(wide_datalvals0.9_res1[, 3:13]), latlon = TRUE, na.rm=TRUE, resamp =1000)

#plot results
plot(Correlog_res1, main = "Spline correlogram for residuals")


```


### Fig. S10
plot the temporal and spatial correlation plots together

```{r}
pdf("GLMMrescorr.pdf", width = 5)# default height and width are both 7
par(mfrow = c(2, 1), oma = c(3.5, 4, 2, 1))
par(mar=c(1, 0, 5, 0))
#plot the mean acfs
barplot(apply(mod9fUCA_resid_acf, 1, function(x) mean(x, na.rm=T)), ylim = c(-0.4, 1), xlab=NA, ylab=NA, las = 1, xaxs = "i")
abline(h=0)
box()# add frame around the plot
axis(side=1, at=c(0.75,  1.95,  3.15,  4.35,  5.55,  6.75,  7.95,  9.15, 10.35, 11.55, 12.75), labels=c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10),las=0, cex.axis=1)
mtext(side = 1, "Lag (years)", line = 2.5)
mtext(side = 2, "ACF", line = 2.5)
mtext(side = 3, "a) Residual temporal autocorrelation", adj = 0)

#plot the spine correlogram
plot(Correlog_res1, main = NA, xlab = NA, ylab = NA, las = 1, xaxs =  "i")
mtext(side = 1, "Distance between transects (km)", line = 2.5)
mtext(side = 2, "Correlation", line = 2.5)
mtext(side = 3, "b) Residual spatial autocorrelation", adj = 0)
dev.off()


#seq(from = 0.75, to = 20, by=1.2)[1:11]

```

## significance

use Wald chi-squared test to test for significance of fixed effects; in the Anova function in car package (https://cran.r-project.org/web/packages/car/car.pdf)


```{r}

Anova(mod9fUCA)

```

# no outliers

repeat all of the above GLMM analyses with the residual outliers removed

## data prep

```{r}
datalvals0.92 <- full_data_for_mod[c(-144, -176, -177,- 179),]# make new dataframe without the 4 outliers

datalvals0.92[ ,26] <- full_data_for_mod[c(-144, -176, -177,- 179), 14+5]#add a column with the conn values for the loss rate = 0.9 (column 19)

colnames(datalvals0.92)[26] <- "patch_conn"#name this column patch_conn; note this is called patch_conn but it is really log transformed (same with urchin_dens and patch_area)

```

## fitting

random effects selection

```{r}

mod9nor3 <- glmer(kelp_status ~ urchin_dens*patch_conn + patch_area  + (1|patch) + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit)) 

#summary(mod9nor3) # patch has tiny variance

# remove random effect of patch and refit
mod9nor2 <- glmer(kelp_status ~ urchin_dens*patch_conn + patch_area  + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit))

#compare estimates with and without patch random effect
sapply(list(mod9nor3, mod9nor2), logLik)
sapply(list(mod9nor3, mod9nor2), fixef)
sapply(list(mod9nor3, mod9nor2), function(x) unlist(VarCorr(x)))
#singular with random effect of patch, but estimates with and without patch are basically the same

```

fixed effects selection

```{r}
mod9nof0 <- glmer(kelp_status ~ (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit))#null model (no fixed effects)

mod9nofU <- glmer(kelp_status ~ urchin_dens + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit))#urchins only

mod9nofC <- glmer(kelp_status ~ patch_conn + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit))#connectivity only

mod9nofA <- glmer(kelp_status ~ patch_area + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit))# patch area only

mod9nofUC <- glmer(kelp_status ~ urchin_dens + patch_conn + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit))# urchins and connectivity

mod9nofUA <- glmer(kelp_status ~ urchin_dens + patch_area + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit))#urchins and patch area

mod9nofCA <- glmer(kelp_status ~ patch_conn + patch_area  + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit))# connectivity and patch area

mod9nofUCA <- glmer(kelp_status ~ urchin_dens + patch_conn + patch_area  + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit)) #urchins, connectivity, and patch area

mod9nofUxC <- glmer(kelp_status ~ urchin_dens*patch_conn + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit))# urchin x connectivity

mod9nofUxCA <- glmer(kelp_status ~ urchin_dens*patch_conn + patch_area  + (1|transect_id) + (1|fyear), data=datalvals0.92, family = binomial(link=logit))# urchin x connectivity and patch area

```


```{r}
#get AICs and weights

mod9no_AICs <- AIC(mod9nof0, mod9nofU, mod9nofC, mod9nofA, mod9nofUC, mod9nofUA, mod9nofCA, mod9nofUCA, mod9nofUxC, mod9nofUxCA)

#get the delta AIC values
mod9no_deltas <- deltaAIC.fun(mod9no_AICs[, 2], min(mod9no_AICs[, 2]))

#get the weights
mod9no_weights <- as.vector(round(Weights(mod9no_AICs[, 2]), 3))

# add the delta AICs and weights to the AIC dataframe
mod9no_AICs$delta <- mod9no_deltas
mod9no_AICs$weights <- mod9no_weights

mod9no_AICs <- mod9no_AICs[order(mod9no_AICs$AIC), ] 

mod9no_AICs

# rename rows
mod9no_AICs2 <- mod9no_AICs
rownames(mod9no_AICs2) <- NULL
rownames(mod9no_AICs2) <- c("UCA", "UxCA", "UC", "UxC", "UA", "U", "CA", "C", "A", "0")

#mod9_AICs2

# round for displaying the table
mod9no_AICs2 <- mod9no_AICs2 %>% mutate(AIC = round(AIC, 1), delta = round(delta, 1), weights = round(weights, 1))

# save the AIC table
pdf("AICGLMMnotable.pdf")#, height = 50*nrow(mod_AICs2), width = 200*ncol(mod_AICs2)
grid.table(mod9no_AICs2, theme = ttheme_minimal(core = list(bg_params=list(fill=rep(NA,11), col="black")))) # ingridExtra package
dev.off()

```

## check assumptions

check that the best-fitting model meets GLMM assumptions

### vif

```{r}
vif(mod9nofUCA)# these are all less than 1.5
```


### residuals

```{r}
#look at partial residuals vs predictors

plot(x=datalvals0.92$urchin_dens, y=partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$urchin_dens, fixef(mod9nofUCA)[2]), xlab = "log(urchin density)", ylab = "Partial residuals", ylim = c(-20, 10))#ylim = c(-10, 10)
lines(lowess(datalvals0.92$urchin_dens, partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$urchin_dens, fixef(mod9nofUCA)[2])), col='red')
#text(x =datalvals0.92$urchin_dens, y = partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$urchin_dens, fixef(mod9nofUCA)[2]), labels = rownames(datalvals0.92),  cex=0.9)

plot(x=datalvals0.92$patch_conn, y=partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$patch_conn, fixef(mod9nofUCA)[3]), xlab = "log(patch connectivity)", ylab = "Partial residuals", ylim = c(-20, 10))#ylim = c(-10, 10)
lines(lowess(datalvals0.92$patch_conn, partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$patch_conn, fixef(mod9nofUCA)[3])), col='red')
#text(x =datalvals0.92$patch_conn, y = partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$patch_conn, fixef(mod9nofUCA)[3]), labels = rownames(datalvals0.92),  cex=0.9)


plot(x=datalvals0.92$patch_area, y=partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$patch_area, fixef(mod9nofUCA)[4]), xlab = "log(patch area)", ylab = "Partial residuals", ylim = c(-20, 10))#ylim = c(-10, 10)
lines(lowess(datalvals0.92$patch_area, partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$patch_area, fixef(mod9nofUCA)[4])), col='red')
#text(x =datalvals0.92$patch_area, y = partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$patch_area, fixef(mod9nofUCA)[4]), labels = rownames(datalvals0.92),  cex=0.9)


#DHARMa residual plots
mod9nofUCA_simres2 <- simulateResiduals(mod9nofUCA)
plot(mod9nofUCA_simres2)

```

### Fig. S12

plot the predictors vs. partial residuals altogether for the GLMM without outliers
```{r}
pdf("GLMMpartialresNO.pdf", height = 7/2.5)# default height and width are both 7
par(mfrow = c(1, 3), oma = c(3.5, 4, 2, 1))
layout(matrix(c(1, 2, 3), nrow = 1, ncol = 3), widths = rep.int(1, 3), heights = rep.int(1, 1))
par(mar=c(0.05, 0, 0, 0.5))
plot(x=datalvals0.92$urchin_dens, y=partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$urchin_dens, fixef(mod9nofUCA)[2]), xlab = NA, ylab = NA, ylim = c(-20, 10), pch = 16, yaxt = "n")#ylim = c(-10, 10)
lines(lowess(datalvals0.92$urchin_dens, partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$urchin_dens, fixef(mod9nofUCA)[2])), col='blue')
axis(side = 2, at = c(-20, -10, 0, 10), las = 1)
mtext(side = 1, "Urchin density (log scale)", line = 2.5, cex = 0.8)
mtext(side = 2, "Partial residuals", line = 2.5, cex = 0.8)
mtext(side = 3, "a) Urchin density", adj = 0)

plot(x=datalvals0.92$patch_conn, y=partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$patch_conn, fixef(mod9nofUCA)[3]), xlab = NA, ylab = NA, ylim = c(-20, 10), yaxt = "n", pch = 16)#ylim = c(-10, 10)
lines(lowess(datalvals0.92$patch_conn, partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$patch_conn, fixef(mod9nofUCA)[3])), col='blue')
axis(side = 2, at = c(-20, -10, 0, 10), NA)
mtext(side = 1, "Patch connectivity (log scale)", line = 2.5, cex = 0.8)
#mtext(side = 2, "Partial residuals", line = 2.5)
mtext(side = 3, "b) Patch connectivity", adj = 0)

plot(x=datalvals0.92$patch_area, y=partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$patch_area, fixef(mod9nofUCA)[4]), xlab = NA, ylab = NA, ylim = c(-20, 10), yaxt = "n", pch = 16)#ylim = c(-10, 10)
lines(lowess(datalvals0.92$patch_area, partial_res.fn(datalvals0.92$kelp_status, fitted(mod9nofUCA), datalvals0.92$patch_area, fixef(mod9nofUCA)[4])), col='blue')
axis(side = 2, at = c(-20, -10, 0, 10), NA)
mtext(side = 1, "Patch area (log scale)", line = 2.5, cex = 0.8)
#mtext(side = 2, "Partial residuals", line = 2.5)
mtext(side = 3, "c) Patch area", adj = 0)
dev.off()


```

### random effects

check the qq plots for transect and year


```{r}
#uses sjPlot package
#type = "diag": For generalized linear mixed models, returns the QQ-plot for random effects.

plot_model(mod9nofUCA, type = "diag")[1]#transects

plot_model(mod9nofUCA, type = "diag")[2]#years


```

### autocorrelation

temporal

```{r}
# get the acf values for the residuals as a vector for each transect, then put all these together, then get the mean for each lag, and for each transect get the number of ACF values > than the CIs

transect_ids2 <- as.vector(unique(datalvals0.92$transect_id))#all the transect_ids
#empty matrices for the acf and pacf values
mod9nofUCA_resid_acf2 <- matrix(NA, 11, length(transect_ids2))#max is 11 years
mod9nofUCA_resid_pacf2 <- matrix(NA, 10, length(transect_ids2))#pacf is one less than acf


#empty vectors for number of acf and pacf values outside of confidence intervals
mod9nofUCA_sig_res_acf2 <- rep(NA, length(transect_ids2))
mod9nofUCA_sig_res_pacf2 <- rep(NA, length(transect_ids2))

for(i in 1:length(transect_ids2)){#for each transect
  temp_data1 <- resid(mod9nofUCA, type = "pearson")[which(datalvals0.92$transect_id==transect_ids2[i])]#subset out the ith transect
  temp_data2 <- temp_data1[order(datalvals0.92[which(datalvals0.92$transect_id==transect_ids2[i]), ]$year)] #order the observations by year
  
  n_obs <- length(temp_data2)#number of years transect was monitored
  
  #get the acf and pacf values
  mod9nofUCA_resid_acf2[1:n_obs, i] <- as.vector(acf(temp_data2, plot=F)$acf)
  
  mod9nofUCA_resid_pacf2[1:(n_obs-1), i] <- as.vector(pacf(temp_data2, plot=F)$acf)
  
  #get the number that are outside confidence intervals
  mod9nofUCA_sig_res_acf2[i] <- length(which(abs(mod9nofUCA_resid_acf2[ ,i]) > qnorm((1 + 0.95)/2)/sqrt(n_obs)))
  
  mod9nofUCA_sig_res_pacf2[i] <- length(which(abs(mod9nofUCA_resid_pacf2[ ,i]) > qnorm((1 + 0.95)/2)/sqrt(n_obs)))
  
}


which(mod9nofUCA_sig_res_acf2>1)# none are outside the confidence intervals

which(mod9nofUCA_sig_res_pacf2>1)


#plot the mean acfs
barplot(apply(mod9nofUCA_resid_acf2, 1, function(x) mean(x, na.rm=T)), ylim = c(-0.4, 1), xlab="Time lag (yrs)", ylab="mean ACF", main="Temporal autocorrelation plot for residuals")
abline(h=0)
#axis(side=1, at=c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11), labels=c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10),las=0, cex.axis=1)


```

spatial

```{r}
#library(ncf)


#get data frame with just the locations (lat, lon), observation (kelp status), and year and use spread to make each year its own column
#add the transect lat and long and model residuals to the data frame
datalvals0.9_res2 <- left_join(datalvals0.92[,c(3,8)], trans_coords, by = "transect_id") #%>% dplyr::select(Latitude, Longitude, year)
datalvals0.9_res2$UCAr <- resid(mod9nofUCA, type = "pearson")

#View(datalvals0.9_res)# just want latitude, longitude, year, and residual columns 

wide_datalvals0.9_res21 <- datalvals0.9_res2[ ,c(2, 3:5)] %>% spread(year, UCAr)
#View(wide_datalvals0.9_res21)

#splinecorrelogram with transect coords
Correlog_res21 <- spline.correlog(x = wide_datalvals0.9_res21$Longitude,
y = wide_datalvals0.9_res21$Latitude,
z = as.matrix(wide_datalvals0.9_res21[, 3:13]), latlon = TRUE, na.rm=TRUE, resamp =1000)

#plot results
plot(Correlog_res21, main = "Spline correlogram for residuals")

```


## significance

```{r}
Anova(mod9nofUCA)

#Anova(mod9fUCA)


```

# Fig S15

get the bootstrapped confidence intervals of the fixed effects for the GLMM fit with the full dataset and with residual outliers removed

note this takes about 15 min
```{r}

tic()#start timing

# full data
set.seed(100)
mod9fUCA_boot <- confint(mod9fUCA, parm=c("urchin_dens", "patch_conn", "patch_area"), level=0.95, method="boot", nsim=1000)

# without outliers
set.seed(100)
mod9nofUCA_boot2 <- confint(mod9nofUCA, parm=c("urchin_dens", "patch_conn", "patch_area"), level=0.95, method="boot", nsim=1000)

toc()#935.568 sec


```


plot fixed effects and confidence intervals with and without outliers (Fig. S15)

```{r}
#mod9nofUCA_boot2 # rows 1, 2, 3 = urchins, conn, area, col 1 = lower, 2 = upper

#fixef(mod9nofUCA)[2] 2 = urchin density, 3 = patch_conn, 4 = patch_area

full.col <- "sienna1"
noout.col <- "deepskyblue"

pdf("GLMMcoeffcis.pdf", width = 5, height = 4)
plot(x = fixef(mod9fUCA)[2], y = 1 + 0.05, type = "p", pch = 16, xlim = c(-2.8, 2.6), ylim = c(0, 1.2), xlab = "Value of coefficient", yaxt = "n", ylab = NA, col = full.col)
points(x = fixef(mod9fUCA)[3], y = 0.6 + 0.05, type = "p", pch = 16, col = full.col)
points(x = fixef(mod9fUCA)[4], y = 0.2 + 0.05, type = "p", pch = 16, col = full.col)
points(x = fixef(mod9nofUCA)[2], y = 1-0.05, type = "p", pch = 16, col = noout.col)
points(x = fixef(mod9nofUCA)[3], y = 0.6-0.05, type = "p", pch = 16, col = noout.col)
points(x = fixef(mod9nofUCA)[4], y = 0.2-0.05, type = "p", pch = 16, col = noout.col)
segments(mod9fUCA_boot[1, 1], 1 + 0.05, mod9fUCA_boot[1,2], 1 + 0.05, col = full.col)
segments(mod9fUCA_boot[2, 1], 0.6 + 0.05, mod9fUCA_boot[2,2], 0.6 + 0.05, col = full.col)
segments(mod9fUCA_boot[3, 1], 0.2 + 0.05, mod9fUCA_boot[3,2], 0.2 + 0.05, col = full.col)
segments(mod9nofUCA_boot2[1, 1], 1 - 0.05, mod9nofUCA_boot2[1,2], 1 - 0.05, col = noout.col)
segments(mod9nofUCA_boot2[2, 1], 0.6 - 0.05, mod9nofUCA_boot2[2,2], 0.6 - 0.05, col = noout.col)
segments(mod9nofUCA_boot2[3, 1], 0.2 - 0.05, mod9nofUCA_boot2[3,2], 0.2 - 0.05, col = noout.col)
text(x = fixef(mod9fUCA)[2], y = 1 + 0.12, expression("p=6.4x10"^-8), col = full.col, cex = 0.6)
text(x = fixef(mod9fUCA)[3], y = 0.6 + 0.12, "p=0.0013", col = full.col, cex = 0.6)
text(x = fixef(mod9fUCA)[4], y = 0.2 + 0.12, "p=0.016", col = full.col, cex = 0.6)
text(x = fixef(mod9nofUCA)[2], y = 1 - 0.12, expression("p=1.9x10"^-7), col = noout.col, cex = 0.6)
text(x = fixef(mod9nofUCA)[3], y = 0.6 - 0.12, "p=0.0015", col = noout.col, cex = 0.6)
text(x = fixef(mod9nofUCA)[4], y = 0.2 - 0.12, "p=0.02", col = noout.col, cex = 0.6)
axis(side = 2, at = c(0.2, 0.6, 1), labels = c("patch \narea", "patch \nconn", "urchin \ndensity"), las = 1)
legend("topright", legend = c("full data", "no outliers"), col = c(full.col, noout.col), lwd = 1, bty = "n")
abline(v = 0, lty = 2)
mtext(side = 3, "GLMM fixed effects") #adj = 0
dev.off()


```

## values for Fig 5
```{r}
# get the coefficient and CI values for patch connectivity and urchin density (no outliers model) to add to Figure 5b and 5c in "format_data.Rmd"

# urchin density
fixef(mod9nofUCA)[2] # mean
mod9nofUCA_boot2[1,1] # lower CI
mod9nofUCA_boot2[1,2] # upper CI

# patch connectivity
fixef(mod9nofUCA)[3] # mean
mod9nofUCA_boot2[2,1] # lower CI
mod9nofUCA_boot2[2,2] # upper CI

mod9nofUCA_boot2
fixef(mod9nofUCA)

```


# Fig S16 and S17

plot predictions and CIs for connectivity = 0.15, 0.5, and 0.85 with the actual data

```{r}
# data for generating GLMM predictions
#urchins
#range(full_datalvals$urchin_dens)
#quantile(full_datalvals$urchin_dens, 0.9)#90% quantile is around 50
urchset <- c(seq(from = 0, to = 50, by = 1), 75, 100, 165)

# log transform these to get them on the same scale as the model input
urchsetL <- log(urchset+1)

# area: want the mean of the log transformed data
areasetL <- rep(mean(full_data_for_mod$patch_area), length(urchsetL))# remember full_data_for_mod$patch_area is already log transformed

# patch connectivity: get the 0.15, 0.5, and 0.85 quantiles (the midpoints of each third of the data)
patch_connq15 <- as.numeric(quantile(full_data_for_mod$patch_conn0.9, 0.15))
patch_connq50 <- as.numeric(quantile(full_data_for_mod$patch_conn0.9, 0.50))
patch_connq85 <- as.numeric(quantile(full_data_for_mod$patch_conn0.9, 0.85))

# define function to make the predictor data frames for different connectivity values
predictordf.fun <- function(patch_connq.f){
  
  predictordata <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(patch_connq.f, length(urchsetL)),
    patch_area = areasetL)
  
  return(predictordata)
  
}


# define function for getting GLMM predictions and CIs
predCI.fun <- function(GLMM.f, predictordata.f, patch_connq.f){
  
# predictions
predictions <- predict(GLMM.f, re.form=NA, newdata=predictordata.f, type="response")

# confidence intervals
  set.seed(100)
  CIvals <- bootMer(GLMM.f, FUN=function(x) predict(x,re.form=NA, newdata=predictordata.f, type="response"), nsim=1000)
  CI95 <- t(apply(CIvals$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
  
# add the predictions and cis to dataframe
  predCI.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(patch_connq.f, length(urchsetL)),
    patch_area = areasetL,
    pred = predictions,
    CI.low = CI95[ ,1],
    CI.up = CI95[ ,2])
  
  return(predCI.df)

}


```


Get the predictions and bootstrapped confidence intervals

note this takes around 50 min
```{r}
# get the predictor data frames for each level of patch connectivity
dataq15 <- predictordf.fun(patch_connq15)
dataq50 <- predictordf.fun(patch_connq50)
dataq85 <- predictordf.fun(patch_connq85)

# get the predictions and confidence intervals
#tic()
#predCIq15 <- predCI.fun(mod9fUCA, dataq15, patch_connq15)
#predCIq50 <- predCI.fun(mod9fUCA, dataq50, patch_connq50)
#predCIq85 <- predCI.fun(mod9fUCA, dataq85, patch_connq85)

#predCIq15no <- predCI.fun(mod9nofUCA, dataq15, patch_connq15)
#predCIq50no <- predCI.fun(mod9nofUCA, dataq50, patch_connq50)
#predCIq85no <- predCI.fun(mod9nofUCA, dataq85, patch_connq85)
#toc()

# get the predictions from the GLMMs for each level of patch connectivity
# full data
predq15 <- predict(mod9fUCA, re.form=NA, newdata=dataq15, type="response")
predq50 <- predict(mod9fUCA, re.form=NA, newdata=dataq50, type="response")
predq85 <- predict(mod9fUCA, re.form=NA, newdata=dataq85, type="response")

# no outliers
predq15no <- predict(mod9nofUCA, re.form=NA, newdata=dataq15, type="response")
predq50no <- predict(mod9nofUCA, re.form=NA, newdata=dataq50, type="response")
predq85no <- predict(mod9nofUCA, re.form=NA, newdata=dataq85, type="response")

# do the bootstrapping to get the confidence intervals for these GLMM predictions

tic()
# full data
set.seed(100)
  CIvalsq15 <- bootMer(mod9fUCA, FUN=function(x) predict(x,re.form=NA, newdata=dataq15, type="response"), nsim=1000)
  CI95q15 <- t(apply(CIvalsq15$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
  
set.seed(100)
  CIvalsq50 <- bootMer(mod9fUCA, FUN=function(x) predict(x,re.form=NA, newdata=dataq50, type="response"), nsim=1000)
  CI95q50 <- t(apply(CIvalsq50$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs

  set.seed(100)
  CIvalsq85 <- bootMer(mod9fUCA, FUN=function(x) predict(x,re.form=NA, newdata=dataq85, type="response"), nsim=1000)
  CI95q85 <- t(apply(CIvalsq85$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs

  # no outliers
  set.seed(100)
  CIvalsq15no <- bootMer(mod9nofUCA, FUN=function(x) predict(x,re.form=NA, newdata=dataq15, type="response"), nsim=1000)
  CI95q15no <- t(apply(CIvalsq15no$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
 
set.seed(100)
  CIvalsq50no <- bootMer(mod9nofUCA, FUN=function(x) predict(x,re.form=NA, newdata=dataq50, type="response"), nsim=1000)
  CI95q50no <- t(apply(CIvalsq50no$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
  
  set.seed(100)
  CIvalsq85no <- bootMer(mod9nofUCA, FUN=function(x) predict(x,re.form=NA, newdata=dataq85, type="response"), nsim=1000)
  CI95q85no <- t(apply(CIvalsq85no$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
toc() #2931 seconds


```


```{r}
# make the data frames with the GLMM predictions and CIs for the different levels of patch connectivity
# full data
predCIq15.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(patch_connq15, length(urchsetL)),
    patch_area = areasetL,
    pred = predq15,
    CI.low = CI95q15[ ,1],
    CI.up = CI95q15[ ,2])

predCIq50.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(patch_connq50, length(urchsetL)),
    patch_area = areasetL,
    pred = predq50,
    CI.low = CI95q50[ ,1],
    CI.up = CI95q50[ ,2])

predCIq85.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(patch_connq85, length(urchsetL)),
    patch_area = areasetL,
    pred = predq85,
    CI.low = CI95q85[ ,1],
    CI.up = CI95q85[ ,2])


# no outliers
predCIq15no.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(patch_connq15, length(urchsetL)),
    patch_area = areasetL,
    pred = predq15,
    CI.low = CI95q15no[ ,1],
    CI.up = CI95q15no[ ,2])

predCIq50no.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(patch_connq50, length(urchsetL)),
    patch_area = areasetL,
    pred = predq50,
    CI.low = CI95q50no[ ,1],
    CI.up = CI95q50no[ ,2])

predCIq85no.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(patch_connq85, length(urchsetL)),
    patch_area = areasetL,
    pred = predq85,
    CI.low = CI95q85no[ ,1],
    CI.up = CI95q85no[ ,2])

```


plot the results


```{r}
# first break up the data into thirds by patch connectivity

full_data_for_plot <- full_datalvals %>% mutate(kelp_status=if_else(is.na(kelp_dens)==T, as.numeric(NA), if_else(kelp_dens>thresh, 1, 0))) %>% mutate(conn_group = if_else(patch_conn0.9<=quantile(patch_conn0.9, 0.333), "33", if_else(patch_conn0.9>quantile(patch_conn0.9, 0.67), "1","67"))) 

full_data_for_plot_no <- full_datalvals[c(-144, -176, -177,- 179),] %>% mutate(kelp_status=if_else(is.na(kelp_dens)==T, as.numeric(NA), if_else(kelp_dens>thresh, 1, 0))) %>% mutate(conn_group = if_else(patch_conn0.9<=quantile(patch_conn0.9, 0.333), "33", if_else(patch_conn0.9>quantile(patch_conn0.9, 0.67), "1","67"))) 

```

plot Fig. S17 (predictions for urchin densities between 0-50)
```{r}
# layout all the plots; have 7 total including the legend, but also add some empty plots to create blank space
#layout(matrix(c(1, 2, 3, 7, 8,4,5, 6, 7, 8), nrow = 5, ncol = 2), widths = rep.int(1, 2), heights = c(0.25, 1.8, 0.25, 0.2, 0.2))
#layout.show(8)# show all 8  plots

pdf("GLMMpredictions.pdf", height = 5)
par(mfrow = c(5, 2), oma = c(2, 4, 2, 1))
layout(matrix(c(1, 2, 3, 7, 8,4,5, 6, 7, 8), nrow = 5, ncol = 2), widths = rep.int(1, 2), heights = c(0.25, 1.8, 0.25, 0.25, 0.25))
par(mar=c(0, 0, 0, 0.5))
# 1 = high kelp for low conn panel #############################################
plot(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==1 & full_data_for_plot$conn_group=="33")], y = rep(0.9, length(which(full_data_for_mod$kelp_status==1 & full_data_for_plot$conn_group=="33"))), type = "p",xlim = c(0, 50), pch = 1, yaxt = "n", xaxt="n",xlab = NA, ylab = NA, ylim = c(0.85, 1.15), col=gray(0.4,0.7))
#axis(1, at = c(0, 10, 20, 30, 40, 50), labels = NA)# to show tick marks but not tick labels, need to make yaxt = "n" then add axis() with labels = NA
lines(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==1 & full_data_for_plot$conn_group=="67")], y = rep(1, length(which(full_data_for_mod$kelp_status==1 & full_data_for_plot$conn_group=="67"))), type = "p", pch = 0, col=adjustcolor("blue", alpha.f=0.6))
lines(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==1 & full_data_for_plot$conn_group=="1")], y = rep(1.1, length(which(full_data_for_mod$kelp_status==1 & full_data_for_plot$conn_group=="1"))), pch = 2, type = "p", col = adjustcolor("red", alpha.f=0.6))
axis(side = 2, at = 1, labels = c("High \nkelp"), las = 1)
mtext("a) Full data", side=3, cex=1, adj = 0,line = 0)
# 2= GLMM predictions for with outliers panel ###########################################
plot(x = urchset, y =predCIq15.df$pred, ylim = c(0,1), type = "l", xlab = NA, ylab = "Prob(high kelp)", lty = 1, col = "black", xlim = c(0,50), las = 1, xaxt="n")# plot the GLMM loss rates
polygon(c(urchset, rev(urchset)), c(predCIq15.df$CI.low, rev(predCIq15.df$CI.up)),  col=gray(0.5,0.2), border = NA)
lines(x = urchset, y = predCIq50.df$pred, type = "l", col = "blue", lwd = 1)
lines(x = urchset, y = predCIq85.df$pred, type = "l", col = "red", lwd = 1)
polygon(c(urchset, rev(urchset)), c(predCIq50.df$CI.low, rev(predCIq50.df$CI.up)),  col=adjustcolor("blue", alpha.f=0.15), border = NA)
polygon(c(urchset, rev(urchset)), c(predCIq85.df$CI.low, rev(predCIq85.df$CI.up)),  col=adjustcolor("red", alpha.f=0.15), border = NA)
#mtext("a) Low connectivity (10% quantile)", side=3, cex=1, adj = 0,line = 0)
mtext("Probability of high kelp", side=2, cex=0.9, outer=TRUE, line = 2.5, adj = 0.65)#adj=0.5
#mtext("Urchin density", side=1, cex=1, line = 2)
#legend(x =17, y = 0.88, legend = c("drift loss = 0.6/d, \nspore loss = 0.99/d", "spore loss = 0.6/d, \nno drift", "no drift or spores"), col= c("darkgoldenrod", "darkgoldenrod", "darkgoldenrod"), lty = c(1, 2, 3), lwd=2, ncol=1, bty="n", y.intersp=1.8)#bty="n"
# 3 = low kelp for low conn panel ###########################################
plot(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==0 & full_data_for_plot$conn_group=="33")], y = rep(-0.1, length(which(full_data_for_mod$kelp_status==0 & full_data_for_plot$conn_group=="33"))), xlim = c(0, 50), pch = 1, ylim = c(-0.2, 0.2), type = "p", yaxt = "n", xlab = NA, ylab = NA, col=gray(0.4,0.7))
lines(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==0 & full_data_for_plot$conn_group=="67")], y = rep(0, length(which(full_data_for_mod$kelp_status==0 & full_data_for_plot$conn_group=="67"))), type = "p", pch = 0, col=adjustcolor("blue", alpha.f=0.6))
lines(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==0 & full_data_for_plot$conn_group=="1")], y = rep(0.1, length(which(full_data_for_mod$kelp_status==0 & full_data_for_plot$conn_group=="1"))), type = "p", pch = 2, col = adjustcolor("red", alpha.f=0.6))
mtext(expression("Urchin density (ind./m"^2*")"), side=1, cex=0.9, line = 2.5)
axis(side = 2, at = 0, labels = c("Low \nkelp"), las = 1)
# 4 = high kelp for no outlier panel #############################################
plot(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==1 & full_data_for_plot_no$conn_group=="33")], y = rep(0.9, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==1 & full_data_for_plot_no$conn_group=="33"))), type = "p",xlim = c(0, 50), pch = 1, xaxt = "n", yaxt = "n", xlab = NA, ylab = NA, ylim = c(0.85, 1.15), col=gray(0.4,0.7))
#axis(2, at = c(0, 0.2, 0.4, 0.6, 0.8, 1), labels = NA)# to show tick marks but not tick labels, need to make yaxt = "n" then add axis() with labels = NA
lines(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==1 & full_data_for_plot_no$conn_group=="67")], y = rep(1, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==1 & full_data_for_plot_no$conn_group=="67"))), type = "p", pch = 0, col=adjustcolor("blue", alpha.f=0.6))
lines(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==1 & full_data_for_plot_no$conn_group=="1")], y = rep(1.1, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==1 & full_data_for_plot_no$conn_group=="1"))), pch = 2, type = "p", col = adjustcolor("red", alpha.f=0.6))
#axis(side = 2, at = 1, labels = c("High \nkelp"), las = 1)
mtext("b) No outliers", side=3, cex=1, adj = 0,line = 0)
# 5 = model predictions for high conn #################################################
plot(x = urchset, y =predCIq15no.df$pred, ylim = c(0,1), type = "l", xlab = NA, ylab = "Prob(high kelp)", lty = 1, col = "black", xlim = c(0,50), las = 1, xaxt="n", yaxt = "n")# plot the GLMM loss rates
axis(2, at = c(0, 0.2, 0.4, 0.6, 0.8, 1), labels = NA)# to show tick marks but not tick labels, need to make yaxt = "n" then add axis() with labels = NA
polygon(c(urchset, rev(urchset)), c(predCIq15no.df$CI.low, rev(predCIq15no.df$CI.up)),  col=gray(0.5,0.2), border = NA)
lines(x = urchset, y = predCIq50no.df$pred, type = "l", col = "blue", lwd = 1)
lines(x = urchset, y = predCIq85no.df$pred, type = "l", col = "red", lwd = 1)
polygon(c(urchset, rev(urchset)), c(predCIq50no.df$CI.low, rev(predCIq50no.df$CI.up)),  col=adjustcolor("blue", alpha.f=0.15), border = NA)
polygon(c(urchset, rev(urchset)), c(predCIq85no.df$CI.low, rev(predCIq85no.df$CI.up)),  col=adjustcolor("red", alpha.f=0.15), border = NA)
#mtext("b) High connectivity (90% quantile)", side=3, cex=1, adj = 0,line = 0)
#mtext("Urchin density", side=1, cex=1, line = 2)
# 6 = low kelp for high conn panel #####################################
plot(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==0 & full_data_for_plot_no$conn_group=="33")], y = rep(-0.1, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==0 & full_data_for_plot_no$conn_group=="33"))), xlim = c(0, 50), pch = 1, ylim = c(-0.2, 0.2), type = "p", yaxt = "n", xlab = NA, ylab = NA, col=gray(0.4,0.7))
lines(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==0 & full_data_for_plot_no$conn_group=="67")], y = rep(0, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==0 & full_data_for_plot_no$conn_group=="67"))), type = "p", pch = 0, col=adjustcolor("blue", alpha.f=0.6))
lines(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==0 & full_data_for_plot_no$conn_group=="1")], y = rep(0.1, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==0 & full_data_for_plot_no$conn_group=="1"))), type = "p", pch = 2, col=adjustcolor("red", alpha.f=0.6))
mtext(expression("Urchin density (ind./m"^2*")"), side=1, cex=0.9, line = 2.5)
#mtext(expression("Urchin density (ind./m"^2*")"), side=1, cex=0.9, line = 2)
#axis(side = 2, at = 0, labels = c("Low \nkelp"), las = 1)
# 7 = blank plot
plot(0,type='n',axes=FALSE, ann = FALSE)# empty plot
# 8= legend ##################################################
plot(0,type='n',axes=FALSE, ann = FALSE)# empty plot
legend(x="bottom", legend = c("0-33", "33-67", "67-100"), col=c("gray40",adjustcolor("blue", alpha.f=0.6), adjustcolor("red", alpha.f=0.6)), pch =  c(1, 0, 2), ncol = 3, bty = "n", cex = 1.5)#title="connectivity quantile"
text(x = 0.78, y = -0.25, "Connectivity \nquantile", cex = 1.1)
dev.off()

```

plot Fig. S16 (same as above but with full range of urchin densities)
```{r}

pdf("GLMMpredictions2.pdf", height = 5)
par(mfrow = c(5, 2), oma = c(2, 4, 2, 1))
layout(matrix(c(1, 2, 3, 7, 8,4,5, 6, 7, 8), nrow = 5, ncol = 2), widths = rep.int(1, 2), heights = c(0.25, 1.8, 0.25, 0.25, 0.25))
par(mar=c(0, 0, 0, 0.5))
# 1 = high kelp for full data panel #############################################
plot(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==1 & full_data_for_plot$conn_group=="33")], y = rep(0.9, length(which(full_data_for_mod$kelp_status==1 & full_data_for_plot$conn_group=="33"))), type = "p", pch = 1, yaxt = "n", xaxt="n",xlab = NA, ylab = NA, ylim = c(0.85, 1.15), xlim = c(0, 166), col=gray(0.4,0.7))
#axis(1, at = c(0, 10, 20, 30, 40, 50), labels = NA)# to show tick marks but not tick labels, need to make yaxt = "n" then add axis() with labels = NA
lines(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==1 & full_data_for_plot$conn_group=="67")], y = rep(1, length(which(full_data_for_mod$kelp_status==1 & full_data_for_plot$conn_group=="67"))), type = "p", pch = 0, col=adjustcolor("blue", alpha.f=0.6))
lines(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==1 & full_data_for_plot$conn_group=="1")], y = rep(1.1, length(which(full_data_for_mod$kelp_status==1 & full_data_for_plot$conn_group=="1"))), pch = 2, type = "p", col = adjustcolor("red", alpha.f=0.6))
axis(side = 2, at = 1, labels = c("High \nkelp"), las = 1)
mtext("a) Full data", side=3, cex=1, adj = 0,line = 0)
# 2= GLMM predictions for with outliers panel ###########################################
plot(x = urchset, y =predCIq15.df$pred, ylim = c(0,1), type = "l", xlab = NA, ylab = "Prob(high kelp)", lty = 1, col = "black", las = 1, xaxt="n", xlim = c(0, 166))# plot the GLMM loss rates
polygon(c(urchset, rev(urchset)), c(predCIq15.df$CI.low, rev(predCIq15.df$CI.up)),  col=gray(0.5,0.2), border = NA)
lines(x = urchset, y = predCIq50.df$pred, type = "l", col = "blue", lwd = 1)
lines(x = urchset, y = predCIq85.df$pred, type = "l", col = "red", lwd = 1)
polygon(c(urchset, rev(urchset)), c(predCIq50.df$CI.low, rev(predCIq50.df$CI.up)),  col=adjustcolor("blue", alpha.f=0.15), border = NA)
polygon(c(urchset, rev(urchset)), c(predCIq85.df$CI.low, rev(predCIq85.df$CI.up)),  col=adjustcolor("red", alpha.f=0.15), border = NA)
#mtext("a) Low connectivity (10% quantile)", side=3, cex=1, adj = 0,line = 0)
mtext("Probability of high kelp", side=2, cex=0.9, outer=TRUE, line = 2.5, adj = 0.65)
#mtext("Urchin density", side=1, cex=1, line = 2)
#legend(x =17, y = 0.88, legend = c("drift loss = 0.6/d, \nspore loss = 0.99/d", "spore loss = 0.6/d, \nno drift", "no drift or spores"), col= c("darkgoldenrod", "darkgoldenrod", "darkgoldenrod"), lty = c(1, 2, 3), lwd=2, ncol=1, bty="n", y.intersp=1.8)#bty="n"
# 3 = low kelp for low conn panel ###########################################
plot(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==0 & full_data_for_plot$conn_group=="33")], y = rep(-0.1, length(which(full_data_for_mod$kelp_status==0 & full_data_for_plot$conn_group=="33"))), pch = 1, ylim = c(-0.2, 0.2), type = "p", yaxt = "n", xlab = NA, ylab = NA, xlim = c(0, 166), col=gray(0.4,0.7))
lines(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==0 & full_data_for_plot$conn_group=="67")], y = rep(0, length(which(full_data_for_mod$kelp_status==0 & full_data_for_plot$conn_group=="67"))), type = "p", pch = 0, col=adjustcolor("blue", alpha.f=0.6))
lines(x = full_data_for_plot$urchin_dens[which(full_data_for_plot$kelp_status==0 & full_data_for_plot$conn_group=="1")], y = rep(0.1, length(which(full_data_for_mod$kelp_status==0 & full_data_for_plot$conn_group=="1"))), type = "p", pch = 2, col = adjustcolor("red", alpha.f=0.6))
mtext(expression("Urchin density (ind./m"^2*")"), side=1, cex=0.9, line = 2.5)
axis(side = 2, at = 0, labels = c("Low \nkelp"), las = 1)
# 4 = high kelp for no outlier panel #############################################
plot(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==1 & full_data_for_plot_no$conn_group=="33")], y = rep(0.9, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==1 & full_data_for_plot_no$conn_group=="33"))), type = "p", pch = 1, xaxt = "n", yaxt = "n", xlab = NA, ylab = NA, ylim = c(0.85, 1.15), xlim = c(0, 166), col=gray(0.4,0.7))
#axis(2, at = c(0, 0.2, 0.4, 0.6, 0.8, 1), labels = NA)# to show tick marks but not tick labels, need to make yaxt = "n" then add axis() with labels = NA
lines(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==1 & full_data_for_plot_no$conn_group=="67")], y = rep(1, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==1 & full_data_for_plot_no$conn_group=="67"))), type = "p", pch = 0, col=adjustcolor("blue", alpha.f=0.6))
lines(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==1 & full_data_for_plot_no$conn_group=="1")], y = rep(1.1, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==1 & full_data_for_plot_no$conn_group=="1"))), pch = 2, type = "p", col = adjustcolor("red", alpha.f=0.6))
#axis(side = 2, at = 1, labels = c("High \nkelp"), las = 1)
mtext("b) No outliers", side=3, cex=1, adj = 0,line = 0)
# 5 = model predictions for high conn #################################################
plot(x = urchset, y =predCIq15no.df$pred, ylim = c(0,1), type = "l", xlab = NA, ylab = "Prob(high kelp)", lty = 1, col = "black", las = 1, xaxt="n", yaxt = "n", xlim = c(0, 166))# plot the GLMM loss rates
axis(2, at = c(0, 0.2, 0.4, 0.6, 0.8, 1), labels = NA)# to show tick marks but not tick labels, need to make yaxt = "n" then add axis() with labels = NA
polygon(c(urchset, rev(urchset)), c(predCIq15no.df$CI.low, rev(predCIq15no.df$CI.up)),  col=gray(0.5,0.2), border = NA)
lines(x = urchset, y = predCIq50no.df$pred, type = "l", col = "blue", lwd = 1)
lines(x = urchset, y = predCIq85no.df$pred, type = "l", col = "red", lwd = 1)
polygon(c(urchset, rev(urchset)), c(predCIq50no.df$CI.low, rev(predCIq50no.df$CI.up)),  col=adjustcolor("blue", alpha.f=0.15), border = NA)
polygon(c(urchset, rev(urchset)), c(predCIq85no.df$CI.low, rev(predCIq85no.df$CI.up)),  col=adjustcolor("red", alpha.f=0.15), border = NA)
#mtext("b) High connectivity (90% quantile)", side=3, cex=1, adj = 0,line = 0)
#mtext("Urchin density", side=1, cex=1, line = 2)
# 6 = low kelp for no outliers panel #####################################
plot(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==0 & full_data_for_plot_no$conn_group=="33")], y = rep(-0.1, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==0 & full_data_for_plot_no$conn_group=="33"))), pch = 1, ylim = c(-0.2, 0.2), type = "p", yaxt = "n", xlab = NA, ylab = NA, xlim = c(0, 166), col=gray(0.4,0.7))
lines(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==0 & full_data_for_plot_no$conn_group=="67")], y = rep(0, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==0 & full_data_for_plot_no$conn_group=="67"))), type = "p", pch = 0, col=adjustcolor("blue", alpha.f=0.6))
lines(x = full_data_for_plot_no$urchin_dens[which(full_data_for_plot_no$kelp_status==0 & full_data_for_plot_no$conn_group=="1")], y = rep(0.1, length(which(full_data_for_mod[c(-144, -176, -177,- 179),]$kelp_status==0 & full_data_for_plot_no$conn_group=="1"))), type = "p", pch = 2, col=adjustcolor("red", alpha.f=0.6))
mtext(expression("Urchin density (ind./m"^2*")"), side=1, cex=0.9, line = 2.5)
#axis(side = 2, at = 0, labels = c("Low \nkelp"), las = 1)
# 7 = blank plot
plot(0,type='n',axes=FALSE, ann = FALSE)# empty plot
# 8= legend ##################################################
plot(0,type='n',axes=FALSE, ann = FALSE)# empty plot
legend(x="bottom", legend = c("0-33", "33-67", "67-100"), col=c("gray40",adjustcolor("blue", alpha.f=0.6), adjustcolor("red", alpha.f=0.6)), pch =  c(1, 0, 2), ncol = 3, bty = "n", cex = 1.5)#title="connectivity quantile"
text(x = 0.78, y = -0.25, "Connectivity \nquantile", cex = 1.1)
dev.off()


#full_datalvals$kelp_dens[which(full_datalvals$urchin_dens>50)]

#max(full_datalvals$urchin_dens)

```

# predictions for ODE validation

get the predictions and CIs for the 10% and 90% quantiles of patch connectivity (plotted in Fig. 6)

Note this takes about 40 min (to do the bootstrapping for the confidence intervals)

```{r}
#View(full_datalvals)
#colnames(full_datalvals)[19]
# get the 10% and 90% quantiles of patchc onnectivity
q10.i <- quantile(as.data.frame(full_datalvals)[,19], 0.1) # column 19 = patch conn for loss rate = 0.9
q90.i <- quantile(as.data.frame(full_datalvals)[,19], 0.9)
  
# get the connectivity values in the data closest to these quantiles
q10.approx <- as.data.frame(full_datalvals)[,19][which(abs(as.data.frame(full_datalvals)[,19]-q10.i)==min(abs(as.data.frame(full_datalvals)[,19]-q10.i)))][1]# take the first (for cases with multiple transects in same patch)
  
q90.approx <- as.data.frame(full_datalvals)[,19][which(abs(as.data.frame(full_datalvals)[,19]-q90.i)==min(abs(as.data.frame(full_datalvals)[,19]-q90.i)))][1]

#log transform patch connectivity to get values on the same scale as the GLMM model input (full_datalvals data frame is not already log transformed)
q10.approxL <- log(q10.approx +1) 
q90.approxL <- log(q90.approx +1) 

# now get the predictor data frames
dataq10 <- predictordf.fun(q10.approxL)
dataq90 <- predictordf.fun(q90.approxL)

# get the predictions
predq10no <- predict(mod9nofUCA, re.form=NA, newdata=dataq10, type="response")
predq90no <- predict(mod9nofUCA, re.form=NA, newdata=dataq90, type="response")

predq10 <- predict(mod9fUCA, re.form=NA, newdata=dataq10, type="response")
predq90 <- predict(mod9fUCA, re.form=NA, newdata=dataq90, type="response")


# do the bootstrapping
tic()
set.seed(100)
  CIvalsq10no <- bootMer(mod9nofUCA, FUN=function(x) predict(x,re.form=NA, newdata=dataq10, type="response"), nsim=1000)
  #CI95q50no <- t(apply(CIvalsq50no$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
  
  set.seed(100)
  CIvalsq90no <- bootMer(mod9nofUCA, FUN=function(x) predict(x,re.form=NA, newdata=dataq90, type="response"), nsim=1000)
  toc() #1029 sec
  

tic()
set.seed(100)
  CIvalsq10 <- bootMer(mod9fUCA, FUN=function(x) predict(x,re.form=NA, newdata=dataq10, type="response"), nsim=1000)
  #CI95q50no <- t(apply(CIvalsq50no$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
  
  set.seed(100)
  CIvalsq90 <- bootMer(mod9fUCA, FUN=function(x) predict(x,re.form=NA, newdata=dataq90, type="response"), nsim=1000)
  toc() #1403.497 sec
  
# get the 95% confidence intervals
CI95q10no <- t(apply(CIvalsq10no$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
CI95q90no <- t(apply(CIvalsq90no$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
  
CI95q10 <- t(apply(CIvalsq10$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
CI95q90 <- t(apply(CIvalsq90$t,2,quantile,c(0.025,0.975),na.rm=TRUE))#95% CIs
 
  
# make the data frames with the predictions and confidence intervals
# no outliers
predCIq10no.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(q10.approxL, length(urchsetL)),
    patch_area = areasetL,
    pred = predq10no,
    CI.low = CI95q10no[ ,1],
    CI.up = CI95q10no[ ,2])

predCIq90no.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(q90.approxL, length(urchsetL)),
    patch_area = areasetL,
    pred = predq90no,
    CI.low = CI95q90no[ ,1],
    CI.up = CI95q90no[ ,2])

# full data
predCIq10.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(q10.approxL, length(urchsetL)),
    patch_area = areasetL,
    pred = predq10,
    CI.low = CI95q10[ ,1],
    CI.up = CI95q10[ ,2])

predCIq90.df <- data.frame(
    urchin_dens = urchsetL,
    patch_conn = rep(q90.approxL, length(urchsetL)),
    patch_area = areasetL,
    pred = predq90,
    CI.low = CI95q90[ ,1],
    CI.up = CI95q90[ ,2])

```

## export predictions

Export the GLMM predictions (these will be plotted in Fig. 6, which is made in "ODE_GLMM_comparison.Rmd")

```{r}
# no outliers
write.csv(predCIq10no.df, "../../../intermediate_data_output/GLMM_data/glmmq10no.csv")

write.csv(predCIq90no.df, "../../../intermediate_data_output/GLMM_data/glmmq90no.csv")

# with outliers included
write.csv(predCIq10.df, "../../../intermediate_data_output/GLMM_data/glmmq10.csv")

write.csv(predCIq90.df, "../../../intermediate_data_output/GLMM_data/glmmq90.csv")

```

```{r}
# check which patches/years correspond to the 10% and 90% quantiles
full_datalvals[which(abs(as.data.frame(full_datalvals)[,19]-q10.i)==min(abs(as.data.frame(full_datalvals)[,19]-q10.i))),] # patch 221, year 2000, sem 1, but this is 1 sem lag, so connectivity values are really from 1999 semester 2

full_datalvals[which(abs(as.data.frame(full_datalvals)[,19]-q90.i)==min(abs(as.data.frame(full_datalvals)[,19]-q90.i))),] # patch 174, year 2004, sem 2, but this is 1 sem lag, so connectivity values are really from 2004 semester 1

```


# reason for outliers

There were 4 outliers in the residuals where there are no urchins and connectivity is high but there is low kelp. Here, check whether this was because the transects had high sand percent cover (note: sand/substrate cover was not included as a predictor in the model because it is measured differently in SBC vs. KFM, but all the outliers are at SBC sites so that doesn't matter here)

```{r}
# download the substrate data

# Package ID: knb-lter-sbc.138.3 Cataloging System:https://pasta.edirepository.org.
# Data set title: SBC LTER: Reef: Kelp Forest Community Dynamics: Cover of bottom substrate and sand depth.
# Data set creator:    - Santa Barbara Coastal LTER 
# Data set creator:  Daniel C Reed -  
# Data set creator:  Robert J Miller -  
# Contact:    - Information Manager, Santa Barbara Coastal LTER   - sbclter@msi.ucsb.edu
# Stylesheet v2.11 for metadata conversion into program: John H. Porter, Univ. Virginia, jporter@virginia.edu 

subUrl  <- "https://pasta.lternet.edu/package/data/eml/knb-lter-sbc/138/3/82d1b4ba2b2c1b5438ae1279e19bf68b" 
subfile <- tempfile()
try(download.file(subUrl,subfile,method="curl"))
if (is.na(file.size(subfile))) download.file(subUrl,subfile,method="auto")

                   
 lter_sub <-read.csv(subfile,header=F,skip=1 ,sep=",",quot='"', col.names=c("YEAR", "MONTH", "DATE", "SITE", "TRANSECT", "QUAD", "SIDE", "SUBSTRATE_TYPE", "COMMON_NAME", "PERCENT_COVER"), check.names=TRUE)
               
unlink(subfile)
		    
# Fix any interval or ratio columns mistakenly read in as nominal and nominal columns read as numeric or dates read as strings
                                                   
# attempting to convert lter_sub$DATE dateTime string to R date structure (date or POSIXct)                                
tmpDateFormat<-"%Y-%m-%d"
tmp1DATE<-as.Date(lter_sub$DATE,format=tmpDateFormat)
# Keep the new dates only if they all converted correctly
if(length(tmp1DATE) == length(tmp1DATE[!is.na(tmp1DATE)])){lter_sub$DATE <- tmp1DATE } else {print("Date conversion failed for lter_sub$DATE. Please inspect the data and do the date conversion yourself.")}                                                                    
rm(tmpDateFormat,tmp1DATE) 
if (class(lter_sub$SITE)!="factor") lter_sub$SITE<- as.factor(lter_sub$SITE)
if (class(lter_sub$TRANSECT)!="factor") lter_sub$TRANSECT<- as.factor(lter_sub$TRANSECT)
if (class(lter_sub$QUAD)!="factor") lter_sub$QUAD<- as.factor(lter_sub$QUAD)
if (class(lter_sub$SIDE)!="factor") lter_sub$SIDE<- as.factor(lter_sub$SIDE)
if (class(lter_sub$SUBSTRATE_TYPE)!="factor") lter_sub$SUBSTRATE_TYPE<- as.factor(lter_sub$SUBSTRATE_TYPE)
if (class(lter_sub$COMMON_NAME)!="factor") lter_sub$COMMON_NAME<- as.factor(lter_sub$COMMON_NAME)
if (class(lter_sub$PERCENT_COVER)=="factor") lter_sub$PERCENT_COVER <-as.numeric(levels(lter_sub$PERCENT_COVER))[as.integer(lter_sub$PERCENT_COVER) ]               
if (class(lter_sub$PERCENT_COVER)=="character") lter_sub$PERCENT_COVER <-as.numeric(lter_sub$PERCENT_COVER)
                
# Convert Missing Values to NA for non-dates
                
lter_sub$SITE <- as.factor(ifelse((trimws(as.character(lter_sub$SITE))==trimws("-99999")),NA,as.character(lter_sub$SITE)))
lter_sub$TRANSECT <- as.factor(ifelse((trimws(as.character(lter_sub$TRANSECT))==trimws("-99999")),NA,as.character(lter_sub$TRANSECT)))
lter_sub$QUAD <- as.factor(ifelse((trimws(as.character(lter_sub$QUAD))==trimws("-99999")),NA,as.character(lter_sub$QUAD)))
lter_sub$SIDE <- as.factor(ifelse((trimws(as.character(lter_sub$SIDE))==trimws("-99999")),NA,as.character(lter_sub$SIDE)))
lter_sub$SUBSTRATE_TYPE <- as.factor(ifelse((trimws(as.character(lter_sub$SUBSTRATE_TYPE))==trimws("-99999")),NA,as.character(lter_sub$SUBSTRATE_TYPE)))
lter_sub$COMMON_NAME <- as.factor(ifelse((trimws(as.character(lter_sub$COMMON_NAME))==trimws("-99999")),NA,as.character(lter_sub$COMMON_NAME)))
lter_sub$PERCENT_COVER <- ifelse((trimws(as.character(lter_sub$PERCENT_COVER))==trimws("-99999")),NA,lter_sub$PERCENT_COVER)               
suppressWarnings(lter_sub$PERCENT_COVER <- ifelse(!is.na(as.numeric("-99999")) & (trimws(as.character(lter_sub$PERCENT_COVER))==as.character(as.numeric("-99999"))),NA,lter_sub$PERCENT_COVER))


```



```{r}

#head(lter_sub)

# get transect level mean percent cover of each substrate type
#lter_sub2 <- lter_sub %>% mutate(site.trans = paste(SITE, TRANSECT, sep = ".")) %>% rename(year = YEAR) %>% filter(site.trans %in% full_datalvals$site.trans) %>% filter(year %in% full_datalvals$year) %>% group_by(year, SITE, TRANSECT, site.trans, SUBSTRATE_TYPE, COMMON_NAME) %>% summarise(PERCENT_COVER = mean(PERCENT_COVER, na.rm = T))

# total sand (shallow and deep)
lter_sub2 <- lter_sub %>% mutate(site.trans = paste(SITE, TRANSECT, sep = ".")) %>% rename(year = YEAR) %>% filter(site.trans %in% full_datalvals$site.trans) %>% filter(year %in% full_datalvals$year) %>% mutate(softsubs = if_else(COMMON_NAME %in%c("Sand", "Shallow Sand"), 1, 0)) %>% filter(softsubs==1)%>% group_by(year, SITE, TRANSECT,QUAD, SIDE, site.trans) %>% summarise(PERCENT_COVER_S = sum(PERCENT_COVER, na.rm = T)) %>% ungroup() %>% group_by(year, SITE, TRANSECT, site.trans) %>% summarise(PERCENT_COVER = mean(PERCENT_COVER_S, na.rm = T), N_SAMP = n(), SE_PER_COV = sd(PERCENT_COVER_S)/N_SAMP) %>% filter(site.trans %in% c("BULL.3", "BULL.1", "BULL.6", "IVEE.2", "IVEE.1", "AQUE.4", "AQUE.3", "AQUE.5")) %>% filter(SITE=="BULL" & year ==2004 | SITE %in%c("AQUE", "IVEE") & year==2005) %>% left_join(full_datalvals, by = c("site.trans", "year")) %>% dplyr::select(year, SITE, TRANSECT, site.trans, PERCENT_COVER, N_SAMP, SE_PER_COV, urchin_dens, kelp_dens) %>% mutate(site.trans.yr = paste(site.trans, year, sep = "."))
#%>% filter(year %in% c(2004, 2005))# %>% group_by(site.trans) %>% mutate(mean_sand = mean(PERCENT_COVER)) %>% ungroup() %>% mutate(mean_diff = PERCENT_COVER-mean_sand)

# larger time window
lter_sub3 <- lter_sub %>% mutate(site.trans = paste(SITE, TRANSECT, sep = ".")) %>% rename(year = YEAR) %>% filter(site.trans %in% full_datalvals$site.trans) %>% filter(year %in% full_datalvals$year) %>% mutate(softsubs = if_else(COMMON_NAME %in%c("Sand", "Shallow Sand"), 1, 0)) %>% filter(softsubs==1)%>% group_by(year, SITE, TRANSECT,QUAD, SIDE, site.trans) %>% summarise(PERCENT_COVER_S = sum(PERCENT_COVER, na.rm = T)) %>% ungroup() %>% group_by(year, SITE, TRANSECT, site.trans) %>% summarise(PERCENT_COVER = mean(PERCENT_COVER_S, na.rm = T), N_SAMP = n(), SE_PER_COV = sd(PERCENT_COVER_S)/N_SAMP) %>% filter(site.trans %in% c("BULL.3", "BULL.1", "BULL.6", "IVEE.2", "IVEE.1", "AQUE.4", "AQUE.3", "AQUE.5")) %>% filter(year %in% c(2003, 2004, 2005, 2006)) %>% left_join(full_datalvals, by = c("site.trans", "year")) %>% dplyr::select(year, SITE, TRANSECT, site.trans, PERCENT_COVER, N_SAMP, SE_PER_COV, urchin_dens, kelp_dens) %>% mutate(site.trans.yr = paste(site.trans, year, sep = "."))
#%>% filter(year %in% c(2004, 2005))# %>% group_by(site.trans) %>% mutate(mean_sand = mean(PERCENT_COVER)) %>% ungroup() %>% mutate(mean_diff = PERCENT_COVER-mean_sand)



#levels(lter_sub2$COMMON_NAME)

#View(lter_sub2)

lter_sub2%>% filter(year == 2004) %>% filter(site.trans == "BULL.3")
lter_sub2 %>% filter(year == 2005) %>% filter(site.trans == "IVEE.1")
lter_sub2 %>% filter(year == 2005) %>% filter(site.trans == "AQUE.4")
lter_sub2 %>% filter(year == 2005) %>% filter(site.trans == "AQUE.3")

```



```{r}
# check which transects/years were outliers
full_datalvals[c(144, 176, 177,179),]

# check all the transects in these patches
unique(full_datalvals$site.trans[which(full_datalvals$patch %in% full_datalvals$patch[c(144, 176, 177,179)])])

```


### Fig. S13

plot sand cover vs. kelp density
```{r}
# define point type for each of the 3 patches
pch190 <- 15
pch174 <- 16
pch152 <- 17

#pch = ifelse(lter_sub2$SITE=="BULL", 15, ifelse(lter_sub2$SITE=="AQUE", 16, 17))
#col = ifelse(lter_sub2$kelp_dens<0.05, "red", "black")

pdf("Outliersandvkelp.pdf", height = 5)
plot(x = lter_sub2$PERCENT_COVER/100, y = lter_sub2$kelp_dens, pch = ifelse(lter_sub2$site.trans.yr=="BULL.3.2004" , 0, ifelse(lter_sub2$site.trans.yr %in% c("AQUE.3.2005","AQUE.4.2005"), 1, ifelse(lter_sub2$site.trans.yr=="IVEE.1.2005", 2, ifelse(lter_sub2$SITE=="BULL" & lter_sub2$site.trans.yr!="BULL.3.2004", 15, ifelse(lter_sub2$SITE=="IVEE" & lter_sub2$site.trans.yr!="IVEE.1.2005", 17, 16))))), xlab = NA, ylab = NA, cex = 1.2)
mtext(side = 1, "Mean fraction sand cover in transect", line = 2)
mtext(side = 2, expression("Kelp density (ind./m"^2*") in transect"), line = 2)
mtext(side = 3, "Sand cover vs. kelp density")
legend("topright", legend = c("190 (BULL)", "174 (AQUE)", "152 (IVEE)"), pch = c(pch190, pch174, pch152), title = "Patch (Site)", bty = "n")
abline(h = thresh, lty = 2)
# ADD SEs to this
#for(i in 1:length(lter_sub2$PERCENT_COVER)){
 # arrows(lter_sub2$PERCENT_COVER[i]-lter_sub2$SE_PER_COV[i], lter_sub2$kelp_dens[i], lter_sub2$PERCENT_COVER[i]+lter_sub2$SE_PER_COV[i], lter_sub2$kelp_dens[i], length=0.05, angle=90, code=3, col = ifelse(lter_sub2$kelp_dens[i]<0.05, "red", "black")) 
#}
dev.off()

# x0, y0, x1, y1

```

### Fig. S14

plot time series of kelp density and sand cover

```{r}
#layout(matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3), widths = rep.int(1, 3), heights =rep.int(1, 3))
#layout.show(6)

pdf("Outlierplots.pdf", height = 5)
par(mfrow = c(2, 3), oma = c(2, 2, 2, 1))
layout(matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3), widths = rep.int(1, 3), heights =rep.int(1, 3))
par(mai=c(0.15,0.3,0.01,0))
# BULL kelp
plot(x = lter_sub3$year[which(lter_sub3$site.trans=="BULL.1")], y = lter_sub3$kelp_dens[which(lter_sub3$site.trans=="BULL.1")], type = "o", pch = pch190 , xlab = NA, ylab=NA, ylim = c(0, 0.8), las = 1, xaxt = "n")
axis(side = 1, at = c(2003, 2004, 2005, 2006), labels = NA)
lines(x = lter_sub3$year[which(lter_sub3$site.trans=="BULL.3")], y = lter_sub3$kelp_dens[which(lter_sub3$site.trans=="BULL.3")], type = "o",pch = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="BULL.3")]=="BULL.3.2004", 0, pch190), lty = 2, cex = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="BULL.3")]=="BULL.3.2004", 1.3, 1))
lines(x = lter_sub3$year[which(lter_sub3$site.trans=="BULL.6")], y = lter_sub3$kelp_dens[which(lter_sub3$site.trans=="BULL.6")], type = "o", pch = pch190, lty = 3)
#points(x = 2004, y =lter_sub3$kelp_dens[which(lter_sub3$site.trans=="BULL.3" & lter_sub3$year==2004)], pch = pch190, col = "red", cex = 1.2)
legend(x = "topleft", legend = c("BULL.1", "BULL.3", "BULL.6"), bty = "n", lwd = 2, lty = c(1, 2, 3))
mtext(side = 2, expression("Kelp density (ind./m"^2*")"), line = 2.5)
mtext(side = 3, "Patch 190 (BULL)")

# BULL sand
plot(x = lter_sub3$year[which(lter_sub3$site.trans=="BULL.1")], y = lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="BULL.1")]/100, type = "o", pch = pch190, xlab = NA, ylab=NA, ylim = c(0, 1), las = 1, xaxt = "n")
axis(side = 1, at = c(2003, 2004, 2005, 2006), labels = c(2003, 2004, 2005, 2006))
lines(x = lter_sub3$year[which(lter_sub3$site.trans=="BULL.3")], y = lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="BULL.3")]/100, type = "o", pch = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="BULL.3")]=="BULL.3.2004", 0, pch190), lty = 2, cex = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="BULL.3")]=="BULL.3.2004", 1.3, 1))
lines(x = lter_sub3$year[which(lter_sub3$site.trans=="BULL.6")], y = lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="BULL.6")]/100, type = "o", pch = pch190, lty = 3)
#points(x = 2004, y =lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="BULL.3" & lter_sub3$year==2004)]/100, pch = pch190, col = "red", cex = 1.2)
legend(x = "topleft", legend = c("BULL.1", "BULL.3", "BULL.6"), bty = "n", lwd = 2, lty = c(1, 2, 3))
mtext(side = 2, "Fraction sand cover", line = 2.5)
mtext(side = 1, "Year", line = 2)

# AQUE kelp
#lter_sub3 %>% filter(patch == "174")# AQUE.3, 4, 5
plot(x = lter_sub3$year[which(lter_sub3$site.trans=="AQUE.3")], y = lter_sub3$kelp_dens[which(lter_sub3$site.trans=="AQUE.3")], type = "o", pch = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="AQUE.3")]=="AQUE.3.2005", 1, pch174), cex = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="AQUE.3")]=="AQUE.3.2005", 1.3, 1) , xlab = NA, ylab=NA, ylim = c(0, 0.8), xaxt = "n", yaxt = "n", las = 1)
axis(side = 1, at = c(2003, 2004, 2005, 2006), labels = NA)
axis(side = 2, at = c(0, 0.2, 0.4, 0.6, 0.8), labels = NA)
lines(x = lter_sub3$year[which(lter_sub3$site.trans=="AQUE.4")], y = lter_sub3$kelp_dens[which(lter_sub3$site.trans=="AQUE.4")], type = "o", pch = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="AQUE.4")]=="AQUE.4.2005", 1, pch174), cex = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="AQUE.4")]=="AQUE.4.2005", 1.3, 1), lty = 2)
lines(x = lter_sub3$year[which(lter_sub3$site.trans=="AQUE.5")], y = lter_sub3$kelp_dens[which(lter_sub3$site.trans=="AQUE.5")], type = "o", pch = pch174, lty = 3)
#points(x = 2005, y =lter_sub3$kelp_dens[which(lter_sub3$site.trans=="AQUE.4" & lter_sub3$year==2005)], pch = pch174, col = "red", cex = 1.5)
#points(x = 2005, y =lter_sub3$kelp_dens[which(lter_sub3$site.trans=="AQUE.3" & lter_sub3$year==2005)], pch = pch174, col = "red", cex = 1.5)
legend(x = "topleft", legend = c("AQUE.3", "AQUE.4", "AQUE.5"), bty = "n", lwd = 2, lty = c(1, 2, 3))
mtext(side = 3, "Patch 174 (AQUE)")

# AQUE sand
plot(x = lter_sub3$year[which(lter_sub3$site.trans=="AQUE.3")], y = lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="AQUE.3")]/100, type = "o", pch = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="AQUE.3")]=="AQUE.3.2005", 1, pch174), cex = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="AQUE.3")]=="AQUE.3.2005", 1.3, 1), xlab = NA, ylab=NA, ylim = c(0, 1), las = 1, xaxt = "n", yaxt = "n")
axis(side = 1, at = c(2003, 2004, 2005, 2006), labels = c(2003, 2004, 2005, 2006))
axis(side = 2, at = c(0, 0.2, 0.4, 0.6, 0.8, 1), labels = NA)
lines(x = lter_sub3$year[which(lter_sub3$site.trans=="AQUE.4")], y = lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="AQUE.4")]/100, type = "o", pch = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="AQUE.3")]=="AQUE.3.2005", 1, pch174), cex = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="AQUE.3")]=="AQUE.3.2005", 1.3, 1), lty = 2)
lines(x = lter_sub3$year[which(lter_sub3$site.trans=="AQUE.5")], y = lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="AQUE.5")]/100, type = "o", pch = pch174, lty = 3)
#points(x = 2005, y =lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="AQUE.4" & lter_sub3$year==2005)]/100, pch = pch174, col = "red", cex = 1.2)
#points(x = 2005, y =lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="AQUE.3" & lter_sub3$year==2005)]/100, pch = pch174, col = "red", cex = 1.2)
legend(x = "topleft", legend = c("AQUE.3", "AQUE.4", "AQUE.5"), bty = "n", lwd = 2, lty = c(1, 2, 3))
mtext(side = 1, "Year", line = 2)

# IVEE kelp
#lter_sub3 %>% filter(patch == "152")# IVEE.1 and 2

plot(x = lter_sub3$year[which(lter_sub3$site.trans=="IVEE.1")], y = lter_sub3$kelp_dens[which(lter_sub3$site.trans=="IVEE.1")], type = "o", pch = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="IVEE.1")]=="IVEE.1.2005", 2, pch152), cex = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="IVEE.1")]=="IVEE.1.2005", 1.3, 1), xlab = NA, ylab=NA, ylim = c(0, 0.8), xaxt = "n", yaxt = "n")
axis(side = 1, at = c(2003, 2004, 2005, 2006), labels = NA)
axis(side = 2, at = c(0, 0.2, 0.4, 0.6, 0.8), labels = NA)
lines(x = lter_sub3$year[which(lter_sub3$site.trans=="IVEE.2")], y = lter_sub3$kelp_dens[which(lter_sub3$site.trans=="IVEE.2")], type = "o", pch = pch152, lty = 2)
#points(x = 2005, y =lter_sub3$kelp_dens[which(lter_sub3$site.trans=="IVEE.1" & lter_sub3$year==2005)], pch = pch152, col = "red", cex = 1.2)
legend(x = "right", legend = c("IVEE.1", "IVEE.2"), bty = "n", lwd = 2, lty = c(1, 2))
mtext(side = 3, "Patch 152 (IVEE)")

# IVEE sand
plot(x = lter_sub3$year[which(lter_sub3$site.trans=="IVEE.1")], y = lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="IVEE.1")]/100, type = "o", ylim = c(0, 1), pch = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="IVEE.1")]=="IVEE.1.2005", 2, pch152), cex = ifelse(lter_sub3$site.trans.yr[which(lter_sub3$site.trans=="IVEE.1")]=="IVEE.1.2005", 1.3, 1), xlab = NA, ylab=NA, xaxt = "n", yaxt = "n")
axis(side = 1, at = c(2003, 2004, 2005, 2006), labels = c(2003, 2004, 2005, 2006))
axis(side = 2, at = c(0, 0.2, 0.4, 0.6, 0.8, 1), labels = NA)
lines(x = lter_sub3$year[which(lter_sub3$site.trans=="IVEE.2")], y = lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="IVEE.2")]/100, pch = pch152, type = "o", lty =2)
#points(x = 2005, y =lter_sub3$PERCENT_COVER[which(lter_sub3$site.trans=="IVEE.1" & lter_sub3$year==2005)]/100, pch = pch152, col = "red", cex = 1.2)
legend(x = "topleft", legend = c("IVEE.1", "IVEE.2"), bty = "n", lwd = 2, lty = c(1, 2))
mtext(side = 1, "Year", line = 2)
dev.off()

```



Based on the above, it looks like the reason for low kelp in IVEE (and maybe AUQE as well) was likely sand, and the reason for low kelp in BULL and AQUE was likely intrapatch cohort dynamics






